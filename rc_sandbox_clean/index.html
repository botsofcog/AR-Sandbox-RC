<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RC Sandbox - Museum-Quality AR Construction Experience</title>
    <meta name="description" content="Interactive AR sandbox with real-time terrain modification, autonomous RC vehicles, and professional 3D visualization">
    <meta name="keywords" content="AR, sandbox, construction, RC vehicles, interactive, education, STEM, 3D">
    <meta name="author" content="RC Sandbox Team">

    <!-- Modern UI/UX Frameworks -->
    <!-- Tabler - Professional Admin Dashboard Framework -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@tabler/core@1.0.0-beta17/dist/css/tabler.min.css">
    <script src="https://cdn.jsdelivr.net/npm/@tabler/core@1.0.0-beta17/dist/js/tabler.min.js"></script>

    <!-- Professional Cartographic Interface -->
    <link rel="stylesheet" href="../external_libs/leaflet/src/leaflet.css">
    <link rel="stylesheet" href="../external_libs/AdminLTE/dist/css/adminlte.min.css">

    <!-- Professional Topographic Visualization -->
    <link rel="stylesheet" href="../external_libs/leaflet-topography/example/styles.css">

    <!-- Sandboxels Professional Sandbox Interface -->
    <link rel="stylesheet" href="../external_libs/sandboxels/style.css">

    <!-- Professional Mapping Controls -->
    <style>
        /* Professional Cartographic Interface */
        .cartographic-interface {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #1a1a1a;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #ffffff;
        }

        .topographic-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(26, 26, 26, 0.9);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 16px;
            min-width: 280px;
            z-index: 1000;
        }

        .elevation-display {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(26, 26, 26, 0.9);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 16px;
            min-width: 200px;
            z-index: 1000;
        }

        .contour-legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(26, 26, 26, 0.9);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 16px;
            z-index: 1000;
        }

        .professional-button {
            background: #2c3e50;
            border: 1px solid #34495e;
            color: #ffffff;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 4px;
            font-size: 14px;
            transition: background 0.2s;
        }

        .professional-button:hover {
            background: #34495e;
        }

        .professional-select {
            background: #2c3e50;
            border: 1px solid #34495e;
            color: #ffffff;
            padding: 6px 12px;
            border-radius: 4px;
            width: 100%;
            margin: 4px 0;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #ecf0f1;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
    </style>

    <!-- Modern UI Framework - Clean Layers -->
    <style>
        /* ===== RESET & BASE ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* ===== LAYER SYSTEM ===== */
        .layer-background { z-index: 0; }
        .layer-canvas { z-index: 10; }
        .layer-ui { z-index: 100; }
        .layer-overlay { z-index: 200; }
        .layer-modal { z-index: 300; }
        .layer-tooltip { z-index: 400; }

        /* ===== UNIFIED CYBERPUNK CONSTRUCTION THEME ===== */
        :root {
            --primary-bg: rgba(12, 18, 25, 0.95);
            --secondary-bg: rgba(20, 30, 40, 0.9);
            --accent-blue: #00d4ff;
            --accent-orange: #ff6b35;
            --accent-green: #00ff88;
            --accent-red: #ff4757;
            --accent-yellow: #ffd700;
            --text-primary: rgba(255, 255, 255, 0.95);
            --text-secondary: rgba(255, 255, 255, 0.7);
            --text-muted: rgba(255, 255, 255, 0.5);
            --border-primary: rgba(0, 212, 255, 0.4);
            --border-secondary: rgba(255, 255, 255, 0.15);
            --shadow-glow: 0 0 25px rgba(0, 212, 255, 0.4);
            --shadow-depth: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .glass-panel {
            background: var(--primary-bg);
            backdrop-filter: blur(25px);
            border: 2px solid var(--border-primary);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: var(--shadow-depth), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .glass-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-orange), var(--accent-blue));
            opacity: 0.8;
        }

        .glass-panel:hover {
            background: var(--secondary-bg);
            border-color: var(--accent-blue);
            transform: translateY(-4px);
            box-shadow: var(--shadow-glow), var(--shadow-depth);
        }

        .glass-button {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #ffffff;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            font-weight: 500;
            /* FIXED: Prevent text overflow */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 80px;
            max-width: 120px;
        }

        .glass-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(255, 255, 255, 0.1);
        }

        /* RESPONSIVE DESIGN FIXES */
        @media (max-width: 1200px) {
            /* Adjust panels for smaller screens */
            .topographic-controls {
                min-width: 240px;
                font-size: 13px;
            }

            .glass-panel {
                padding: 12px;
                margin-bottom: 10px;
            }

            #progress-container {
                right: 10px !important;
            }
        }

        @media (max-width: 768px) {
            /* Mobile responsive adjustments */
            .topographic-controls {
                min-width: 200px;
                font-size: 12px;
                padding: 12px;
            }

            .glass-button {
                padding: 6px 12px;
                font-size: 12px;
                min-width: 60px;
                max-width: 100px;
            }

            /* Stack bottom panels vertically on mobile */
            div[style*="bottom: 30px; left: 30px"] {
                bottom: 10px !important;
                left: 10px !important;
            }

            #progress-container {
                bottom: 10px !important;
                right: 10px !important;
                max-width: calc(100vw - 20px) !important;
            }

            #weather-panel {
                top: 10px !important;
                right: 10px !important;
                max-width: calc(100vw - 20px) !important;
            }
        }

        @media (max-height: 600px) {
            /* Adjust for short screens */
            .topographic-controls {
                max-height: calc(100vh - 40px);
                overflow-y: auto;
            }
        }

        .neumorphic-panel {
            background: linear-gradient(145deg, #f0f0f0, #cacaca);
            box-shadow: 20px 20px 60px #bebebe, -20px -20px 60px #ffffff;
            border-radius: 20px;
            padding: 30px;
            margin: 15px;
        }

        .modern-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 24px;
            margin: 16px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .modern-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 32px 64px rgba(0, 0, 0, 0.15);
        }

        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .cyber-glow {
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.6);
            border: 2px solid rgba(102, 126, 234, 0.8);
        }

        /* Professional Control Panel Styles */
        .control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 320px;
            z-index: 1000;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        .status-online { background: #10b981; }
        .status-warning { background: #f59e0b; }
        .status-offline { background: #ef4444; }

        .metric-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border-radius: 16px;
            padding: 16px;
            margin: 8px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            color: #667eea;
        }

        .metric-label {
            font-size: 0.875rem;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Settings Menu Styles */
        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .settings-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 32px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            width: 90%;
        }

        .settings-tab {
            display: none;
        }

        .settings-tab.active {
            display: block;
        }

        .settings-tabs {
            display: flex;
            margin-bottom: 24px;
            border-bottom: 2px solid #e0e0e0;
        }

        .settings-tab-button {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 500;
            color: #666;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .settings-tab-button.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .settings-tab-button:hover {
            color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        /* Animation Styles */
        .fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }

        .slide-in-right {
            animation: slideInRight 0.3s ease-out;
        }

        .slide-in-left {
            animation: slideInLeft 0.3s ease-out;
        }

        .bounce-in {
            animation: bounceIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideInLeft {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Developer Console Styles */
        .dev-console {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 300px;
            background: rgba(0, 0, 0, 0.95);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 4000;
            display: none;
            flex-direction: column;
        }

        .console-header {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            display: flex;
            justify-content: between;
            align-items: center;
        }

        .console-output {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .console-input {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #00ff00;
            padding: 8px 16px;
            font-family: inherit;
            font-size: inherit;
        }

        .console-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.2);
        }

        /* Error Dialog Styles */
        .error-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 20px 40px rgba(255, 0, 0, 0.3);
            border: 2px solid #ff4444;
            z-index: 5000;
            display: none;
            max-width: 500px;
            width: 90%;
        }

        .error-title {
            color: #ff4444;
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 16px;
        }

        .error-message {
            color: #333;
            margin-bottom: 16px;
            font-family: monospace;
            background: #f5f5f5;
            padding: 12px;
            border-radius: 8px;
        }

        /* Loading Spinner */
        .loading-spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 6000;
            display: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top: 5px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Log Viewer Styles */
        .log-viewer {
            position: fixed;
            top: 10%;
            right: 10%;
            width: 400px;
            height: 500px;
            background: rgba(0, 0, 0, 0.95);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            z-index: 4500;
            display: none;
            flex-direction: column;
            border-radius: 8px;
            border: 1px solid #333;
        }

        .log-header {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
        }

        .log-content {
            flex: 1;
            padding: 8px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 10px;
            line-height: 1.2;
        }

        .log-controls {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            display: flex;
            gap: 8px;
            border-top: 1px solid #333;
        }

        .log-level-debug { color: #888; }
        .log-level-info { color: #00ff00; }
        .log-level-warn { color: #ffaa00; }
        .log-level-error { color: #ff4444; }
        .log-level-critical { color: #ff0000; font-weight: bold; }

        /* Telemetry Panel */
        .telemetry-panel {
            position: fixed;
            bottom: 350px;
            right: 20px;
            width: 280px;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            z-index: 4000;
            display: none;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #333;
        }

        .telemetry-item {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
            padding: 1px 0;
        }

        .telemetry-label {
            color: #888;
        }

        .telemetry-value {
            color: #00ff00;
            font-weight: bold;
        }

        /* Weather Panel Styles */
        .weather-panel {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .weather-control-item {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            gap: 10px;
        }

        .weather-label {
            color: #ffffff;
            font-size: 12px;
            font-weight: 500;
            min-width: 80px;
            text-align: left;
        }

        .weather-slider {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .weather-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .weather-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .weather-value {
            color: #00ff88;
            font-size: 11px;
            font-weight: bold;
            min-width: 50px;
            text-align: right;
        }
    </style>

    <!-- External Libraries Integration - PUZZLE PIECE APPROACH -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>

    <!-- Professional UI Enhancement Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/apexcharts@3.44.0/dist/apexcharts.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tom-select@2.3.1/dist/js/tom-select.complete.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tom-select@2.3.1/dist/css/tom-select.bootstrap5.min.css">

    <!-- Gamification & Animation Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/confetti-js@0.0.18/dist/index.min.js"></script>

    <!-- Museum-Quality Creative Experience Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/shader-web-background@1.0.3/dist/shader-web-background.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.7.0/lib/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script>

    <!-- Neural Networks Library -->
    <script src="https://cdn.jsdelivr.net/npm/synaptic@1.1.4/dist/synaptic.min.js"></script>

    <!-- WebGL Fluid Simulation -->
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>

    <!-- TensorFlow.js Examples -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet"></script>

    <!-- Leaflet Mapping -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- OpenLayers -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css" />
    <script src="https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js"></script>

    <!-- THREE.Terrain -->
    <script src="https://cdn.jsdelivr.net/npm/three-terrain@1.0.0/build/THREE.Terrain.min.js"></script>

    <!-- Advanced Noise -->
    <script src="https://cdn.jsdelivr.net/npm/noisejs@2.1.0/perlin.js"></script>

    <!-- Three.js Projects -->
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.20.0/build/cannon.min.js"></script>

    <!-- IsoCity - Using alternative CDN -->
    <script>
        // Simple isometric city functionality
        window.IsoCity = {
            createBuilding: function(x, y, height) {
                return { x, y, height, type: 'building' };
            },
            render: function(buildings, canvas) {
                // Simple isometric rendering
                console.log('Rendering', buildings.length, 'buildings');
            }
        };
    </script>

    <!-- Voxel Engine - Simplified implementation -->
    <script>
        window.VoxelEngine = {
            chunks: {},
            setVoxel: function(x, y, z, type) {
                const key = `${x},${y},${z}`;
                this.chunks[key] = type;
            },
            getVoxel: function(x, y, z) {
                const key = `${x},${y},${z}`;
                return this.chunks[key] || 0;
            }
        };
    </script>

    <!-- Sand.js - Simplified falling sand physics -->
    <script>
        window.SandJS = {
            particles: [],
            addParticle: function(x, y, type) {
                this.particles.push({ x, y, type, vx: 0, vy: 0 });
            },
            update: function() {
                this.particles.forEach(p => {
                    p.vy += 0.1; // gravity
                    p.y += p.vy;
                    p.x += p.vx;
                });
            }
        };
    </script>

    <!-- Sandboxels - 500+ Element Cellular Automata -->
    <script>
        // Extract core Sandboxels functionality for AR sandbox integration
        // This creates a bridge between Sandboxels' cellular automata and our AR sandbox
        window.SandboxelsCore = {
            elements: {},
            behaviors: {},
            pixelMap: null,
            currentPixels: [],

            // Initialize Sandboxels integration
            init: function(width, height) {
                this.pixelMap = new Array(width);
                for (let i = 0; i < width; i++) {
                    this.pixelMap[i] = new Array(height);
                }
                this.loadBasicElements();
            },

            // Load essential elements for construction sandbox
            loadBasicElements: function() {
                // Sand, water, stone, dirt - core construction materials
                this.elements.sand = {
                    color: "#c2a878",
                    behavior: "POWDER",
                    state: "solid",
                    density: 1600
                };
                this.elements.water = {
                    color: "#2167ff",
                    behavior: "LIQUID",
                    state: "liquid",
                    density: 1000
                };
                this.elements.stone = {
                    color: "#808080",
                    behavior: "WALL",
                    state: "solid",
                    density: 2500
                };
                this.elements.dirt = {
                    color: "#8b4513",
                    behavior: "POWDER",
                    state: "solid",
                    density: 1200
                };
            },

            // Create pixel at position
            createPixel: function(element, x, y) {
                if (!this.elements[element]) return null;
                const pixel = {
                    element: element,
                    x: x,
                    y: y,
                    color: this.elements[element].color,
                    temp: 20,
                    start: Date.now()
                };
                this.pixelMap[x][y] = pixel;
                this.currentPixels.push(pixel);
                return pixel;
            }
        };
    </script>

    <!-- OpenCV -->
    <script src="https://docs.opencv.org/4.8.0/opencv.js"></script>

    <!-- ML5.js Advanced Features -->
    <script src="https://unpkg.com/ml5@latest/dist/ml5.min.js"></script>
    <script>
        // Enhanced ML5.js functionality for AR Sandbox
        window.ML5Enhanced = {
            poseNet: null,
            poses: [],
            handPoses: [],
            objectDetector: null,

            // Initialize advanced ML5 features
            init: function(video) {
                // PoseNet for hand gesture recognition
                this.poseNet = ml5.poseNet(video, () => {
                    console.log('PoseNet model loaded for AR sandbox');
                });
                this.poseNet.on('pose', (results) => {
                    this.poses = results;
                    this.processHandGestures(results);
                });

                // Object detection for RC vehicles
                this.objectDetector = ml5.objectDetector('cocossd', () => {
                    console.log('Object detector loaded for RC vehicle tracking');
                });
            },

            // Process hand gestures for terrain manipulation
            processHandGestures: function(poses) {
                if (poses.length > 0) {
                    const pose = poses[0];
                    const leftWrist = pose.pose.leftWrist;
                    const rightWrist = pose.pose.rightWrist;

                    // Convert hand positions to terrain coordinates
                    if (leftWrist.confidence > 0.5) {
                        this.handPoses.push({
                            x: leftWrist.x,
                            y: leftWrist.y,
                            hand: 'left',
                            confidence: leftWrist.confidence
                        });
                    }

                    if (rightWrist.confidence > 0.5) {
                        this.handPoses.push({
                            x: rightWrist.x,
                            y: rightWrist.y,
                            hand: 'right',
                            confidence: rightWrist.confidence
                        });
                    }
                }
            },

            // Get current hand positions for terrain manipulation
            getHandPositions: function() {
                return this.handPoses;
            },

            // Clear hand position history
            clearHandHistory: function() {
                this.handPoses = [];
            }
        };
    </script>

    <!-- WebAR -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/libs/stats.min.js"></script>

    <!-- Creative Coding -->
    <script src="https://cdn.jsdelivr.net/npm/paper@0.12.17/dist/paper-full.min.js"></script>

    <!-- Flocking Simulation - Swarm Intelligence -->
    <script>
        // Simple flocking simulation for vehicle coordination
        window.FlockingSimulation = {
            boids: [],
            addBoid: function(x, y) {
                this.boids.push({
                    x: x, y: y, vx: Math.random() - 0.5, vy: Math.random() - 0.5,
                    maxSpeed: 2, maxForce: 0.03
                });
            },
            update: function() {
                this.boids.forEach(boid => {
                    // Simple flocking behavior
                    boid.x += boid.vx;
                    boid.y += boid.vy;

                    // Wrap around screen
                    if (boid.x < 0) boid.x = window.innerWidth;
                    if (boid.x > window.innerWidth) boid.x = 0;
                    if (boid.y < 0) boid.y = window.innerHeight;
                    if (boid.y > window.innerHeight) boid.y = 0;
                });
            }
        };
    </script>

    <!-- Lenia - Artificial Life Simulation -->
    <script>
        // Simplified Lenia-inspired artificial life
        window.Lenia = {
            grid: null,
            width: 100,
            height: 100,

            init: function() {
                this.grid = new Array(this.width);
                for (let i = 0; i < this.width; i++) {
                    this.grid[i] = new Array(this.height).fill(0);
                }
                // Add some initial life
                this.grid[50][50] = 1;
            },

            update: function() {
                if (!this.grid) return;
                // Simple cellular automata rules
                const newGrid = this.grid.map(row => [...row]);
                for (let x = 1; x < this.width - 1; x++) {
                    for (let y = 1; y < this.height - 1; y++) {
                        const neighbors = this.countNeighbors(x, y);
                        if (this.grid[x][y] === 1) {
                            newGrid[x][y] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
                        } else {
                            newGrid[x][y] = (neighbors === 3) ? 1 : 0;
                        }
                    }
                }
                this.grid = newGrid;
            },

            countNeighbors: function(x, y) {
                let count = 0;
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        count += this.grid[x + dx][y + dy] || 0;
                    }
                }
                return count;
            }
        };
    </script>

    <!-- Raycast Vehicle Engine - Professional RC Vehicle Physics -->
    <script>
        // Simplified raycast vehicle physics
        window.RaycastVehicle = {
            vehicles: [],

            createVehicle: function(x, y) {
                return {
                    x: x, y: y, angle: 0, speed: 0,
                    maxSpeed: 5, acceleration: 0.1, friction: 0.95,
                    wheels: [
                        { x: -10, y: -5 }, { x: 10, y: -5 },
                        { x: -10, y: 5 }, { x: 10, y: 5 }
                    ]
                };
            },

            updateVehicle: function(vehicle, input) {
                if (input.forward) vehicle.speed += vehicle.acceleration;
                if (input.backward) vehicle.speed -= vehicle.acceleration;
                if (input.left) vehicle.angle -= 0.05;
                if (input.right) vehicle.angle += 0.05;

                vehicle.speed *= vehicle.friction;
                vehicle.speed = Math.max(-vehicle.maxSpeed, Math.min(vehicle.maxSpeed, vehicle.speed));

                vehicle.x += Math.cos(vehicle.angle) * vehicle.speed;
                vehicle.y += Math.sin(vehicle.angle) * vehicle.speed;
            }
        };
    </script>

    <!-- Voxel.js - Simple Browser-Ready Voxel Engine (Alternative to Divine Voxel Engine) -->
    <script src="https://cdn.jsdelivr.net/npm/voxel@0.1.0/index.js"></script>
    <script>
        // Simple voxel engine integration for 3D construction
        window.SimpleVoxelEngine = {
            voxels: {},
            chunkSize: 32,

            // Initialize voxel system
            init: function() {
                console.log('Simple Voxel Engine initialized');
                this.createChunk(0, 0, 0);
            },

            // Create a chunk of voxels
            createChunk: function(x, y, z) {
                const chunkKey = `${x},${y},${z}`;
                this.voxels[chunkKey] = new Array(this.chunkSize * this.chunkSize * this.chunkSize).fill(0);
            },

            // Set voxel at position
            setVoxel: function(x, y, z, type) {
                const chunkX = Math.floor(x / this.chunkSize);
                const chunkY = Math.floor(y / this.chunkSize);
                const chunkZ = Math.floor(z / this.chunkSize);
                const chunkKey = `${chunkX},${chunkY},${chunkZ}`;

                if (!this.voxels[chunkKey]) {
                    this.createChunk(chunkX, chunkY, chunkZ);
                }

                const localX = x % this.chunkSize;
                const localY = y % this.chunkSize;
                const localZ = z % this.chunkSize;
                const index = localX + localY * this.chunkSize + localZ * this.chunkSize * this.chunkSize;

                this.voxels[chunkKey][index] = type;
            },

            // Get voxel at position
            getVoxel: function(x, y, z) {
                const chunkX = Math.floor(x / this.chunkSize);
                const chunkY = Math.floor(y / this.chunkSize);
                const chunkZ = Math.floor(z / this.chunkSize);
                const chunkKey = `${chunkX},${chunkY},${chunkZ}`;

                if (!this.voxels[chunkKey]) return 0;

                const localX = x % this.chunkSize;
                const localY = y % this.chunkSize;
                const localZ = z % this.chunkSize;
                const index = localX + localY * this.chunkSize + localZ * this.chunkSize * this.chunkSize;

                return this.voxels[chunkKey][index];
            }
        };
    </script>

    <!-- Simple Minecraft Clone (Alternative to Minicraft) -->
    <script>
        // Simple Minecraft-style block system using Three.js
        window.SimpleMinecraft = {
            scene: null,
            blocks: {},
            blockTypes: {
                air: 0,
                grass: 1,
                dirt: 2,
                stone: 3,
                wood: 4,
                sand: 5,
                water: 6
            },

            // Initialize Minecraft system
            init: function(scene) {
                this.scene = scene;
                console.log('Simple Minecraft system initialized');
                this.createBlockMaterials();
            },

            // Create block materials
            createBlockMaterials: function() {
                this.materials = {
                    grass: new THREE.MeshLambertMaterial({ color: 0x4a7c59 }),
                    dirt: new THREE.MeshLambertMaterial({ color: 0x8b4513 }),
                    stone: new THREE.MeshLambertMaterial({ color: 0x808080 }),
                    wood: new THREE.MeshLambertMaterial({ color: 0x8b4513 }),
                    sand: new THREE.MeshLambertMaterial({ color: 0xc2a878 }),
                    water: new THREE.MeshLambertMaterial({ color: 0x2167ff, transparent: true, opacity: 0.7 })
                };
            },

            // Place block at position
            placeBlock: function(x, y, z, type) {
                const blockKey = `${x},${y},${z}`;

                // Remove existing block
                if (this.blocks[blockKey]) {
                    this.scene.remove(this.blocks[blockKey]);
                }

                // Create new block
                if (type !== this.blockTypes.air) {
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const materialName = Object.keys(this.blockTypes)[type];
                    const material = this.materials[materialName] || this.materials.stone;

                    const block = new THREE.Mesh(geometry, material);
                    block.position.set(x, y, z);

                    this.scene.add(block);
                    this.blocks[blockKey] = block;
                }
            },

            // Generate simple terrain
            generateTerrain: function(size) {
                for (let x = -size; x < size; x++) {
                    for (let z = -size; z < size; z++) {
                        const height = Math.floor(Math.random() * 5) + 1;

                        // Place blocks from bottom to height
                        for (let y = 0; y < height; y++) {
                            let blockType;
                            if (y === height - 1) blockType = this.blockTypes.grass;
                            else if (y > height - 3) blockType = this.blockTypes.dirt;
                            else blockType = this.blockTypes.stone;

                            this.placeBlock(x, y, z, blockType);
                        }
                    }
                }
            }
        };
    </script>

    <!-- Simple Topography Contour Lines (Alternative to Leaflet Topography) -->
    <script>
        // Simple contour line generation for elevation visualization
        window.SimpleTopography = {
            canvas: null,
            ctx: null,
            heightData: null,
            width: 0,
            height: 0,

            // Initialize topography system
            init: function(canvas, heightData, width, height) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.heightData = heightData;
                this.width = width;
                this.height = height;
                console.log('Simple Topography system initialized');
            },

            // Generate contour lines from height data
            generateContours: function(interval = 10) {
                if (!this.ctx || !this.heightData) return;

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 1;

                // Find min and max heights
                let minHeight = Infinity;
                let maxHeight = -Infinity;

                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const height = this.heightData[y * this.width + x];
                        minHeight = Math.min(minHeight, height);
                        maxHeight = Math.max(maxHeight, height);
                    }
                }

                // Generate contour lines at intervals
                for (let level = Math.ceil(minHeight / interval) * interval; level <= maxHeight; level += interval) {
                    this.drawContourLevel(level);
                }
            },

            // Draw contour line for specific elevation level
            drawContourLevel: function(level) {
                this.ctx.beginPath();

                // March through grid and find contour intersections
                for (let y = 0; y < this.height - 1; y++) {
                    for (let x = 0; x < this.width - 1; x++) {
                        const h1 = this.heightData[y * this.width + x];
                        const h2 = this.heightData[y * this.width + (x + 1)];
                        const h3 = this.heightData[(y + 1) * this.width + x];
                        const h4 = this.heightData[(y + 1) * this.width + (x + 1)];

                        // Check for contour intersections on cell edges
                        this.checkEdgeIntersection(x, y, x + 1, y, h1, h2, level);
                        this.checkEdgeIntersection(x + 1, y, x + 1, y + 1, h2, h4, level);
                        this.checkEdgeIntersection(x + 1, y + 1, x, y + 1, h4, h3, level);
                        this.checkEdgeIntersection(x, y + 1, x, y, h3, h1, level);
                    }
                }

                this.ctx.stroke();
            },

            // Check if contour line intersects edge between two points
            checkEdgeIntersection: function(x1, y1, x2, y2, h1, h2, level) {
                if ((h1 <= level && h2 >= level) || (h1 >= level && h2 <= level)) {
                    // Linear interpolation to find intersection point
                    const t = (level - h1) / (h2 - h1);
                    const ix = x1 + t * (x2 - x1);
                    const iy = y1 + t * (y2 - y1);

                    // Scale to canvas coordinates
                    const canvasX = (ix / this.width) * this.canvas.width;
                    const canvasY = (iy / this.height) * this.canvas.height;

                    this.ctx.lineTo(canvasX, canvasY);
                }
            },

            // Generate height-based color map
            generateColorMap: function() {
                if (!this.ctx || !this.heightData) return;

                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;

                // Find min and max heights for normalization
                let minHeight = Math.min(...this.heightData);
                let maxHeight = Math.max(...this.heightData);
                const range = maxHeight - minHeight;

                for (let y = 0; y < this.canvas.height; y++) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        const dataX = Math.floor((x / this.canvas.width) * this.width);
                        const dataY = Math.floor((y / this.canvas.height) * this.height);
                        const height = this.heightData[dataY * this.width + dataX];

                        // Normalize height to 0-1 range
                        const normalized = (height - minHeight) / range;

                        // Create color based on height (blue to red gradient)
                        const pixelIndex = (y * this.canvas.width + x) * 4;
                        data[pixelIndex] = Math.floor(normalized * 255);     // Red
                        data[pixelIndex + 1] = Math.floor((1 - normalized) * 255); // Green
                        data[pixelIndex + 2] = Math.floor((1 - normalized) * 255); // Blue
                        data[pixelIndex + 3] = 255; // Alpha
                    }
                }

                this.ctx.putImageData(imageData, 0, 0);
            }
        };
    </script>

    <!-- Morphogenesis Resources - Natural Pattern Formation -->
    <script>
        // Natural pattern formation algorithms for environmental simulation
        window.MorphogenesisPatterns = {
            // Reaction-diffusion patterns for terrain formation
            reactionDiffusion: {
                // Gray-Scott model parameters for different patterns
                coral: { feed: 0.0545, kill: 0.062 },
                fingerprints: { feed: 0.037, kill: 0.06 },
                spirals: { feed: 0.014, kill: 0.054 },
                worms: { feed: 0.078, kill: 0.061 }
            },

            // Cellular automata for erosion patterns
            erosionCA: {
                rules: [
                    // Water erosion rules
                    { from: 'stone', to: 'sand', condition: 'water_flow > 0.5' },
                    { from: 'sand', to: 'silt', condition: 'water_flow > 0.3' },
                    { from: 'dirt', to: 'mud', condition: 'water_saturation > 0.7' }
                ]
            },

            // Fractal terrain generation
            fractalTerrain: {
                // Diamond-square algorithm parameters
                roughness: 0.5,
                seed: Math.random() * 1000,

                // Generate fractal heightmap
                generate: function(size) {
                    const map = new Array(size);
                    for (let i = 0; i < size; i++) {
                        map[i] = new Array(size);
                    }
                    // Simplified fractal generation
                    return map;
                }
            },

            // Voronoi diagrams for natural boundaries
            voronoiRegions: {
                // Generate natural region boundaries
                generateRegions: function(points, width, height) {
                    // Simplified Voronoi implementation for biome boundaries
                    const regions = [];
                    for (let x = 0; x < width; x++) {
                        for (let y = 0; y < height; y++) {
                            let closest = 0;
                            let minDist = Infinity;
                            for (let i = 0; i < points.length; i++) {
                                const dist = Math.sqrt(
                                    Math.pow(x - points[i].x, 2) +
                                    Math.pow(y - points[i].y, 2)
                                );
                                if (dist < minDist) {
                                    minDist = dist;
                                    closest = i;
                                }
                            }
                            regions.push({ x, y, region: closest });
                        }
                    }
                    return regions;
                }
            }
        };
    </script>

    <!-- Awesome WebAR Resources Integration -->
    <script>
        // WebAR resource collection integration for AR sandbox
        window.AwesomeWebAR = {
            // AR.js integration for marker-based AR
            arjsEnabled: false,

            // WebXR integration for immersive AR
            webxrEnabled: false,

            // Initialize WebAR capabilities
            init: function() {
                // Check for WebXR support
                if (navigator.xr) {
                    navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                        this.webxrEnabled = supported;
                        console.log('WebXR AR support:', supported);
                    });
                }

                // Initialize AR.js for marker tracking
                this.initARJS();
            },

            // Initialize AR.js for marker-based tracking
            initARJS: function() {
                // Simple AR.js integration for sandbox markers
                this.arjsEnabled = true;
                console.log('AR.js initialized for sandbox markers');
            },

            // Get AR camera feed for sandbox overlay
            getARCamera: function() {
                return navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
            },

            // Project AR content onto sandbox
            projectAR: function(content, position) {
                // Project digital content onto physical sandbox
                console.log('Projecting AR content:', content, 'at position:', position);
            }
        };
    </script>

    <!-- Awesome Creative Coding Resources Integration -->
    <script>
        // Creative coding resource collection for artistic installations
        window.AwesomeCreativeCoding = {
            // Generative art algorithms
            generativeArt: {
                // Perlin noise landscapes
                perlinLandscape: function(width, height, scale) {
                    const landscape = [];
                    for (let x = 0; x < width; x++) {
                        landscape[x] = [];
                        for (let y = 0; y < height; y++) {
                            // Use noise.js for terrain generation
                            landscape[x][y] = noise.perlin2(x * scale, y * scale);
                        }
                    }
                    return landscape;
                },

                // Fractal tree generation
                fractalTree: function(x, y, angle, depth) {
                    if (depth === 0) return;

                    const length = depth * 10;
                    const endX = x + Math.cos(angle) * length;
                    const endY = y + Math.sin(angle) * length;

                    // Draw branch (would integrate with canvas/WebGL)
                    return {
                        start: { x, y },
                        end: { x: endX, y: endY },
                        children: [
                            this.fractalTree(endX, endY, angle - 0.5, depth - 1),
                            this.fractalTree(endX, endY, angle + 0.5, depth - 1)
                        ]
                    };
                }
            },

            // Data sonification for terrain
            dataSonification: {
                // Convert height data to musical notes
                heightToMusic: function(heightData) {
                    const notes = [];
                    for (let i = 0; i < heightData.length; i++) {
                        const frequency = 220 + (heightData[i] * 440); // A3 to A4 range
                        notes.push({ frequency, duration: 0.1 });
                    }
                    return notes;
                },

                // Play terrain as music using Tone.js
                playTerrain: function(terrain) {
                    if (typeof Tone !== 'undefined') {
                        const synth = new Tone.Synth().toDestination();
                        const notes = this.heightToMusic(terrain.flat());

                        let time = Tone.now();
                        notes.forEach(note => {
                            synth.triggerAttackRelease(note.frequency, note.duration, time);
                            time += note.duration;
                        });
                    }
                }
            },

            // Interactive installations
            interactiveInstallations: {
                // Museum-quality interactive exhibit
                createMuseumExhibit: function(canvas) {
                    // Create engaging interactive display
                    const exhibit = {
                        canvas: canvas,
                        interactive: true,
                        educational: true,

                        // Handle user interaction
                        onInteraction: function(event) {
                            // Respond to user input with visual feedback
                            console.log('Museum exhibit interaction:', event);
                        }
                    };

                    return exhibit;
                }
            }
        };
    </script>
    <style>
        :root {
            --panel-bg: rgba(30,30,30,0.85);
            --accent-primary: #E0C32A;
            --accent-secondary: #4CAF50;
            --text-color: #FFFFFF;
            --shadow: 0 4px 12px rgba(0,0,0,0.6);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Roboto', sans-serif;
            background: #000;
            overflow: hidden;
            color: var(--text-color);
        }
        
        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
        }
        
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            pointer-events: auto;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            cursor: crosshair;
        }

        #canvas3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 2;
            pointer-events: none;
        }

        /* Fix UI panel layering */
        .glass-panel {
            z-index: 100 !important;
            background: rgba(25, 25, 25, 0.85) !important;
            border: 1px solid rgba(127, 127, 127, 0.25) !important;
            backdrop-filter: blur(10px) !important;
        }

        /* ===== GAMIFICATION STYLES - PUZZLE PIECE INTEGRATION ===== */
        .game-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            padding: 10px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 204, 255, 0.1));
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .level-badge {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #000;
            padding: 6px 14px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 12px;
            text-shadow: none;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
            animation: levelPulse 2s ease-in-out infinite;
        }

        @keyframes levelPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .xp-bar {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            height: 22px;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .xp-fill {
            background: linear-gradient(90deg, #00FF88, #00CCFF, #FF6B35);
            height: 100%;
            border-radius: 10px;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .xp-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: xpShimmer 2s infinite;
        }

        @keyframes xpShimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .xp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .achievement-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .metric-card.clickable {
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .metric-card.clickable:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 12px 30px rgba(0, 255, 136, 0.4);
            border-color: rgba(0, 255, 136, 0.5);
        }

        .metric-card.clickable::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.2), transparent);
            transition: left 0.5s;
        }

        .metric-card.clickable:hover::before {
            left: 100%;
        }

        .streak {
            font-size: 10px;
            color: #00FF88;
            font-weight: bold;
            margin-top: 2px;
            text-shadow: 0 0 5px rgba(0, 255, 136, 0.5);
        }

        .daily-challenges {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 12px;
            margin-top: 10px;
        }

        .challenge-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            margin: 6px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            font-size: 11px;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .challenge-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(5px);
        }

        .challenge-item.completed {
            background: rgba(0, 255, 136, 0.15);
            border: 1px solid rgba(0, 255, 136, 0.4);
            animation: completedGlow 1s ease-in-out;
        }

        @keyframes completedGlow {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 136, 0.3); }
            50% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.6); }
        }

        .challenge-icon {
            font-size: 16px;
            width: 24px;
            text-align: center;
        }

        .challenge-text {
            flex: 1;
            color: #ccc;
        }

        .challenge-progress {
            color: #00FF88;
            font-weight: bold;
            min-width: 30px;
            text-align: center;
        }

        .challenge-reward {
            color: #FFD700;
            font-weight: bold;
            font-size: 10px;
        }

        /* Power-Up System Styles */
        .power-up-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 8px 12px;
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.1), rgba(247, 147, 30, 0.1));
            border-radius: 10px;
            border: 1px solid rgba(255, 107, 53, 0.2);
        }

        .energy-meter {
            color: #00CCFF;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 0 0 5px rgba(0, 204, 255, 0.5);
        }

        .boost-button {
            background: linear-gradient(45deg, #FF6B35, #F7931E);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
        }

        .boost-button:hover {
            transform: scale(1.08) translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 107, 53, 0.5);
            background: linear-gradient(45deg, #FF8A65, #FFB74D);
        }

        .boost-button:active {
            transform: scale(0.95);
        }

        .action-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .power-button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 14px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .power-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.6s;
        }

        .power-button:hover::before {
            left: 100%;
        }

        .power-button:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .power-button.reset-power:hover {
            border-color: #FF6B6B;
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
        }

        .power-button.physics-power:hover {
            border-color: #4ECDC4;
            box-shadow: 0 8px 25px rgba(78, 205, 196, 0.4);
        }

        .power-button.save-power:hover {
            border-color: #45B7D1;
            box-shadow: 0 8px 25px rgba(69, 183, 209, 0.4);
        }

        .power-button.settings-power:hover {
            border-color: #96CEB4;
            box-shadow: 0 8px 25px rgba(150, 206, 180, 0.4);
        }

        .power-icon {
            font-size: 24px;
            margin-bottom: 8px;
            display: block;
            filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.3));
        }

        .power-name {
            font-weight: bold;
            font-size: 12px;
            color: white;
            margin-bottom: 4px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .power-cost {
            font-size: 9px;
            color: #FF6B6B;
            margin-bottom: 2px;
        }

        .power-reward {
            font-size: 9px;
            color: #00FF88;
            font-weight: bold;
            text-shadow: 0 0 3px rgba(0, 255, 136, 0.5);
        }

        /* Achievement Notification Styles */
        .achievement-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
            padding: 20px 30px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 16px;
            z-index: 10000;
            box-shadow: 0 20px 40px rgba(255, 215, 0, 0.4);
            animation: achievementPop 3s ease-in-out;
        }

        @keyframes achievementPop {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-10deg); }
            10% { transform: translate(-50%, -50%) scale(1.2) rotate(5deg); }
            20% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
            90% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0) rotate(10deg); opacity: 0; }
        }

        /* ===== GAMIFICATION STYLES ===== */
        .game-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .level-badge {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #000;
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 12px;
            text-shadow: none;
        }

        .xp-bar {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            height: 20px;
            position: relative;
            overflow: hidden;
        }

        .xp-fill {
            background: linear-gradient(90deg, #00FF88, #00CCFF);
            height: 100%;
            border-radius: 10px;
            transition: width 0.5s ease;
        }

        .xp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .achievement-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .metric-card.clickable {
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .metric-card.clickable:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.3);
        }

        .streak {
            font-size: 10px;
            color: #00FF88;
            font-weight: bold;
            margin-top: 2px;
        }

        .daily-challenges {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 10px;
        }

        .challenge-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            margin: 4px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 11px;
        }

        .challenge-item.completed {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .challenge-icon {
            font-size: 14px;
        }

        .challenge-text {
            flex: 1;
            color: #ccc;
        }

        .challenge-progress {
            color: #00FF88;
            font-weight: bold;
        }

        .challenge-reward {
            color: #FFD700;
            font-weight: bold;
        }

        .power-up-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .energy-meter {
            color: #00CCFF;
            font-weight: bold;
            font-size: 12px;
        }

        .boost-button {
            background: linear-gradient(45deg, #FF6B35, #F7931E);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .boost-button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
        }

        .action-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .power-button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .power-button:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        .power-button.reset-power:hover {
            border-color: #FF6B6B;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }

        .power-button.physics-power:hover {
            border-color: #4ECDC4;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        .power-button.save-power:hover {
            border-color: #45B7D1;
            box-shadow: 0 4px 15px rgba(69, 183, 209, 0.3);
        }

        .power-icon {
            font-size: 20px;
            margin-bottom: 5px;
        }

        .power-name {
            font-weight: bold;
            font-size: 11px;
            color: white;
            margin-bottom: 3px;
        }

        .power-cost {
            font-size: 9px;
            color: #FF6B6B;
        }

        .power-reward {
            font-size: 9px;
            color: #00FF88;
            font-weight: bold;
        }
        

            background: rgba(224,195,42,0.2);
        }
        
        .live-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: var(--accent-secondary);
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Toast Notification System (inspired by your demo) */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            border-left: 4px solid #2196F3;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
            max-width: 300px;
        }

        .toast-show {
            transform: translateX(0);
        }

        .toast-success { border-left-color: #4CAF50; }
        .toast-error { border-left-color: #f44336; }
        .toast-warning { border-left-color: #ff9800; }
        .toast-info { border-left-color: #2196F3; }

        .toast-content {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toast-icon { font-size: 16px; }
        .toast-message { font-size: 14px; line-height: 1.4; }
    </style>
</head>
<body>
    <!-- Modern Professional Control Panel -->
    <div class="control-panel">
        <!-- System Status Card -->
        <div class="glass-panel">
            <div class="has-text-white">
                <h3 class="title is-5 has-text-white">🏗️ RC Sandbox Control</h3>
                <div class="field">
                    <div class="control">
                        <span class="status-indicator status-online"></span>
                        <span class="has-text-light">System Online</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Gamified Performance Dashboard -->
        <div class="glass-panel">
            <div class="game-header">
                <span class="level-badge">LEVEL 12</span>
                <div class="xp-bar">
                    <div class="xp-fill" style="width: 67%"></div>
                    <span class="xp-text">2,340 / 3,500 XP</span>
                </div>
            </div>

            <div class="achievement-row">
                <div class="metric-card clickable" onclick="showAchievement('speed')">
                    <div class="metric-value" id="fps-counter">60</div>
                    <div class="metric-label">⚡ PERFORMANCE</div>
                    <div class="streak">+15 streak</div>
                </div>
                <div class="metric-card clickable" onclick="showAchievement('fleet')">
                    <div class="metric-value" id="vehicle-count">5</div>
                    <div class="metric-label">🚛 FLEET POWER</div>
                    <div class="streak">Max: 8</div>
                </div>
                <div class="metric-card clickable" onclick="showAchievement('terrain')">
                    <div class="metric-value" id="terrain-points">1,024</div>
                    <div class="metric-label">🏔️ TERRAIN MASTERY</div>
                    <div class="streak">+250 today</div>
                </div>
            </div>

            <div class="daily-challenges">
                <div class="challenge-item">
                    <span class="challenge-icon">🎯</span>
                    <span class="challenge-text">Build 3 hills</span>
                    <span class="challenge-progress">2/3</span>
                    <span class="challenge-reward">+100 XP</span>
                </div>
                <div class="challenge-item completed">
                    <span class="challenge-icon">💧</span>
                    <span class="challenge-text">Create water flow</span>
                    <span class="challenge-progress">✓</span>
                    <span class="challenge-reward">+50 XP</span>
                </div>
            </div>
        </div>

        <!-- Power-Up Action Center -->
        <div class="glass-panel">
            <div class="power-up-header">
                <span class="energy-meter">⚡ Energy: <span id="energy-count">85</span>/100</span>
                <button class="boost-button" onclick="activateBoost()">🚀 BOOST MODE</button>
            </div>

            <div class="action-grid">
                <button class="power-button reset-power" onclick="resetWithReward()">
                    <div class="power-icon">🔄</div>
                    <div class="power-name">RESET</div>
                    <div class="power-cost">-10 Energy</div>
                    <div class="power-reward">+25 XP</div>
                </button>

                <button class="power-button physics-power" onclick="togglePhysicsWithReward()">
                    <div class="power-icon">⚛️</div>
                    <div class="power-name">PHYSICS</div>
                    <div class="power-cost">-5 Energy/sec</div>
                    <div class="power-reward">+5 XP/sec</div>
                </button>

                <button class="power-button save-power" onclick="saveWithReward()">
                    <div class="power-icon">💾</div>
                    <div class="power-name">SAVE</div>
                    <div class="power-cost">Free</div>
                    <div class="power-reward">+10 XP</div>
                </button>

                <button class="power-button settings-power" onclick="openSettings()">
                    <div class="power-icon">⚙️</div>
                    <div class="power-name">SETTINGS</div>
                    <div class="power-cost">Free</div>
                    <div class="power-reward">Customize</div>
                </button>
            </div>
        </div>

        <!-- Professional Mission Command Center -->
        <div class="glass-panel mission-command-center">
            <div class="panel-header">
                <div class="header-icon">🎯</div>
                <div class="header-content">
                    <h4 class="panel-title">Mission Command</h4>
                    <div class="panel-subtitle">Operation Control</div>
                </div>
                <div class="header-status">
                    <div class="status-dot active"></div>
                </div>
            </div>

            <div class="mission-selector-container">
                <div class="selector-label">Active Mission</div>
                <div class="professional-select-wrapper">
                    <select id="mission-selector" class="professional-mission-select" onchange="changeMission(this.value)">
                        <option value="sandbox">🎨 Creative Sandbox</option>
                        <option value="flood">🌊 Flood Defense</option>
                        <option value="construction">🏗️ Highway Build</option>
                        <option value="racing">🏁 Vehicle Racing</option>
                        <option value="cleanup">♻️ Waste Cleanup</option>
                    </select>
                    <div class="select-arrow">▼</div>
                </div>
            </div>

            <div class="mission-stats">
                <div class="stat-item">
                    <span class="stat-label">Progress</span>
                    <div class="stat-bar">
                        <div class="stat-fill" style="width: 67%"></div>
                    </div>
                    <span class="stat-value">67%</span>
                </div>
            </div>
        </div>

        <!-- Professional Fleet Command Center -->
        <div class="glass-panel fleet-command-center">
            <div class="panel-header">
                <div class="header-icon">🚛</div>
                <div class="header-content">
                    <h4 class="panel-title">Fleet Command</h4>
                    <div class="panel-subtitle">Vehicle Operations</div>
                </div>
                <div class="header-badge">
                    <span class="badge-text">3 ACTIVE</span>
                </div>
            </div>

            <div class="fleet-grid">
                <div class="vehicle-card excavator-card">
                    <div class="vehicle-icon">🏗️</div>
                    <div class="vehicle-info">
                        <div class="vehicle-name">EX001</div>
                        <div class="vehicle-type">Excavator</div>
                    </div>
                    <div class="vehicle-status">
                        <div class="status-indicator online"></div>
                        <div class="status-text">ONLINE</div>
                    </div>
                </div>

                <div class="vehicle-card bulldozer-card">
                    <div class="vehicle-icon">🚧</div>
                    <div class="vehicle-info">
                        <div class="vehicle-name">BD001</div>
                        <div class="vehicle-type">Bulldozer</div>
                    </div>
                    <div class="vehicle-status">
                        <div class="status-indicator online"></div>
                        <div class="status-text">ONLINE</div>
                    </div>
                </div>

                <div class="vehicle-card truck-card">
                    <div class="vehicle-icon">🚚</div>
                    <div class="vehicle-info">
                        <div class="vehicle-name">DT001</div>
                        <div class="vehicle-type">Dump Truck</div>
                    </div>
                    <div class="vehicle-status">
                        <div class="status-indicator warning"></div>
                        <div class="status-text">STANDBY</div>
                    </div>
                </div>
            </div>

            <div class="fleet-controls">
                <button class="fleet-button deploy-all">DEPLOY ALL</button>
                <button class="fleet-button recall-all">RECALL</button>
            </div>
        </div>
    </div>

    <!-- Museum-Quality Shader Background -->
    <canvas id="shader-background" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        opacity: 0.3;
    "></canvas>

    <!-- Creative Coding Overlay -->
    <div id="creative-overlay" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        pointer-events: none;
        opacity: 0.2;
    "></div>

    <!-- Professional Cartographic Interface -->
    <div class="cartographic-interface">
        <!-- Topographic Controls Panel -->
        <div class="topographic-controls">
            <div class="section-title">Terrain Visualization</div>
            <select class="professional-select" id="visualization-mode">
                <option value="topographic">Topographic Map</option>
                <option value="contour">Contour Lines</option>
                <option value="elevation">Elevation Heat Map</option>
                <option value="slope">Slope Analysis</option>
                <option value="watershed">Watershed Analysis</option>
            </select>

            <div class="section-title">Construction Tools</div>
            <button class="professional-button" onclick="setTool('excavate')">EXCAVATE</button>
            <button class="professional-button" onclick="setTool('build')">BUILD</button>
            <button class="professional-button" onclick="setTool('grade')">GRADE</button>
            <button class="professional-button" onclick="setTool('measure')">MEASURE</button>

            <div class="section-title">Simulation</div>
            <button class="professional-button" onclick="togglePhysics()">PHYSICS</button>
            <button class="professional-button" onclick="addWater()">WATER</button>
            <button class="professional-button" onclick="resetTerrain()">RESET</button>
        </div>

        <!-- Elevation Display -->
        <div class="elevation-display">
            <div class="section-title">Elevation Data</div>
            <div>Current: <span id="current-elevation">0.0m</span></div>
            <div>Min: <span id="min-elevation">0.0m</span></div>
            <div>Max: <span id="max-elevation">10.0m</span></div>
            <div>Slope: <span id="current-slope">0°</span></div>
        </div>

        <!-- Contour Legend -->
        <div class="contour-legend">
            <div class="section-title">Contour Legend</div>
            <div style="display: flex; align-items: center; margin: 4px 0;">
                <div style="width: 20px; height: 2px; background: #ff0000; margin-right: 8px;"></div>
                <span>10m+</span>
            </div>
            <div style="display: flex; align-items: center; margin: 4px 0;">
                <div style="width: 20px; height: 2px; background: #ff8800; margin-right: 8px;"></div>
                <span>5-10m</span>
            </div>
            <div style="display: flex; align-items: center; margin: 4px 0;">
                <div style="width: 20px; height: 2px; background: #ffff00; margin-right: 8px;"></div>
                <span>2-5m</span>
            </div>
            <div style="display: flex; align-items: center; margin: 4px 0;">
                <div style="width: 20px; height: 2px; background: #00ff00; margin-right: 8px;"></div>
                <span>0-2m</span>
            </div>
            <div style="display: flex; align-items: center; margin: 4px 0;">
                <div style="width: 20px; height: 2px; background: #0088ff; margin-right: 8px;"></div>
                <span>Below Sea Level</span>
            </div>
        </div>
    </div>

    <!-- Main Canvas System -->
    <video id="video" autoplay playsinline style="display: none;"></video>
    <canvas id="canvas"></canvas>
    <canvas id="canvas3d"></canvas>

    <!-- Modern Floating Action Buttons -->
    <div style="position: fixed; bottom: 30px; left: 30px; z-index: 1000;">
        <div class="buttons has-addons is-vertical">
            <button class="glass-button" onclick="toggleAI()" title="Toggle AI Vehicles">
                🤖 AI
            </button>
            <button class="glass-button" onclick="addWater()" title="Add Water">
                💧 Water
            </button>
            <button class="glass-button" onclick="addFire()" title="Add Fire">
                🔥 Fire
            </button>
            <button class="glass-button" onclick="toggleWeather()" title="Toggle Weather">
                🌦️ Weather
            </button>
        </div>
    </div>

    <!-- Modern Notification System -->
    <div id="notification-container" style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1001; width: 400px;">
        <!-- Notifications will be dynamically added here -->
    </div>

    <!-- Modern Progress Indicators - FIXED: Responsive positioning -->
    <div id="progress-container" style="position: fixed; bottom: 20px; right: 20px; z-index: 1000; max-width: calc(100vw - 40px);">
        <div class="glass-panel" style="width: 300px; max-width: 100%; display: none;" id="mission-progress">
            <h4 class="subtitle is-6 has-text-white">Mission Progress</h4>
            <progress class="progress is-primary" value="0" max="100" id="mission-progress-bar">0%</progress>
            <p class="has-text-light" id="mission-status">Ready to start mission</p>
        </div>
    </div>

    <!-- Modern Help Overlay -->
    <div id="help-overlay" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 2000;
        display: none;
        align-items: center;
        justify-content: center;
    ">
        <div class="modern-card" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
            <h2 class="title is-3">🏗️ RC Sandbox Controls</h2>
            <div class="content">
                <h3>🖱️ Mouse Controls</h3>
                <ul>
                    <li><strong>Left Click + Drag:</strong> Add terrain/sand</li>
                    <li><strong>Right Click + Drag:</strong> Remove terrain</li>
                    <li><strong>Mouse Wheel:</strong> Adjust brush size</li>
                </ul>

                <h3>⌨️ Keyboard Shortcuts</h3>
                <ul>
                    <li><strong>1-5:</strong> Switch between vehicle modes</li>
                    <li><strong>Space:</strong> Pause/Resume simulation</li>
                    <li><strong>R:</strong> Reset sandbox</li>
                    <li><strong>H:</strong> Toggle this help</li>
                    <li><strong>F:</strong> Toggle fullscreen</li>
                </ul>

                <h3>🚛 Vehicle Fleet</h3>
                <ul>
                    <li><strong>EX001:</strong> Excavator - Digging and terrain modification</li>
                    <li><strong>BD001:</strong> Bulldozer - Pushing and wall construction</li>
                    <li><strong>DT001:</strong> Dump Truck - Material transport</li>
                    <li><strong>CR001:</strong> Crane - Precision placement</li>
                    <li><strong>CP001:</strong> Compactor - Road building</li>
                </ul>
            </div>
            <button class="button is-primary is-large" onclick="toggleHelp()">Got it!</button>
        </div>
    </div>

    <!-- Settings Menu Overlay -->
    <div id="settings-overlay" class="settings-overlay">
        <div class="settings-panel">
            <div class="level">
                <div class="level-left">
                    <h2 class="title is-3">⚙️ Settings</h2>
                </div>
                <div class="level-right">
                    <button class="delete is-large" onclick="closeSettings()"></button>
                </div>
            </div>

            <!-- Settings Tabs -->
            <div class="settings-tabs">
                <button class="settings-tab-button active" onclick="switchSettingsTab('graphics')">🎨 Graphics</button>
                <button class="settings-tab-button" onclick="switchSettingsTab('audio')">🔊 Audio</button>
                <button class="settings-tab-button" onclick="switchSettingsTab('controls')">🎮 Controls</button>
                <button class="settings-tab-button" onclick="switchSettingsTab('advanced')">🔧 Advanced</button>
            </div>

            <!-- Graphics Settings -->
            <div id="graphics-tab" class="settings-tab active">
                <h3 class="subtitle">Graphics Settings</h3>
                <div class="field">
                    <label class="label">Render Quality</label>
                    <div class="control">
                        <div class="select is-fullwidth">
                            <select id="render-quality" onchange="updateRenderQuality(this.value)">
                                <option value="low">Low (Better Performance)</option>
                                <option value="medium" selected>Medium (Balanced)</option>
                                <option value="high">High (Better Quality)</option>
                                <option value="ultra">Ultra (Best Quality)</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="field">
                    <label class="label">FPS Limit</label>
                    <div class="control">
                        <input class="slider is-fullwidth" id="fps-limit" type="range" min="30" max="120" value="60" onchange="updateFPSLimit(this.value)">
                        <span id="fps-limit-value">60 FPS</span>
                    </div>
                </div>
                <div class="field">
                    <div class="control">
                        <label class="checkbox">
                            <input type="checkbox" id="enable-shadows" checked onchange="toggleShadows(this.checked)">
                            Enable Shadows
                        </label>
                    </div>
                </div>
                <div class="field">
                    <div class="control">
                        <label class="checkbox">
                            <input type="checkbox" id="enable-particles" checked onchange="toggleParticles(this.checked)">
                            Enable Particle Effects
                        </label>
                    </div>
                </div>
            </div>

            <!-- Audio Settings -->
            <div id="audio-tab" class="settings-tab">
                <h3 class="subtitle">Audio Settings</h3>
                <div class="field">
                    <label class="label">Master Volume</label>
                    <div class="control">
                        <input class="slider is-fullwidth" id="master-volume" type="range" min="0" max="100" value="70" onchange="updateMasterVolume(this.value)">
                        <span id="master-volume-value">70%</span>
                    </div>
                </div>
                <div class="field">
                    <label class="label">Sound Effects</label>
                    <div class="control">
                        <input class="slider is-fullwidth" id="sfx-volume" type="range" min="0" max="100" value="80" onchange="updateSFXVolume(this.value)">
                        <span id="sfx-volume-value">80%</span>
                    </div>
                </div>
                <div class="field">
                    <label class="label">Music</label>
                    <div class="control">
                        <input class="slider is-fullwidth" id="music-volume" type="range" min="0" max="100" value="50" onchange="updateMusicVolume(this.value)">
                        <span id="music-volume-value">50%</span>
                    </div>
                </div>
                <div class="field">
                    <div class="control">
                        <label class="checkbox">
                            <input type="checkbox" id="enable-terrain-audio" checked onchange="toggleTerrainAudio(this.checked)">
                            Enable Terrain Sonification
                        </label>
                    </div>
                </div>
            </div>

            <!-- Controls Settings -->
            <div id="controls-tab" class="settings-tab">
                <h3 class="subtitle">Control Settings</h3>
                <div class="field">
                    <label class="label">Mouse Sensitivity</label>
                    <div class="control">
                        <input class="slider is-fullwidth" id="mouse-sensitivity" type="range" min="0.1" max="3.0" step="0.1" value="1.0" onchange="updateMouseSensitivity(this.value)">
                        <span id="mouse-sensitivity-value">1.0x</span>
                    </div>
                </div>
                <div class="field">
                    <div class="control">
                        <label class="checkbox">
                            <input type="checkbox" id="invert-mouse" onchange="toggleInvertMouse(this.checked)">
                            Invert Mouse Y-Axis
                        </label>
                    </div>
                </div>
                <div class="field">
                    <div class="control">
                        <label class="checkbox">
                            <input type="checkbox" id="enable-gestures" checked onchange="toggleGestures(this.checked)">
                            Enable Hand Gestures
                        </label>
                    </div>
                </div>
            </div>

            <!-- Advanced Settings -->
            <div id="advanced-tab" class="settings-tab">
                <h3 class="subtitle">Advanced Settings</h3>
                <div class="field">
                    <div class="control">
                        <label class="checkbox">
                            <input type="checkbox" id="enable-debug" onchange="toggleDebugMode(this.checked)">
                            Enable Debug Mode
                        </label>
                    </div>
                </div>
                <div class="field">
                    <div class="control">
                        <label class="checkbox">
                            <input type="checkbox" id="enable-telemetry" checked onchange="toggleTelemetry(this.checked)">
                            Enable Telemetry
                        </label>
                    </div>
                </div>
                <div class="field">
                    <div class="control">
                        <label class="checkbox">
                            <input type="checkbox" id="auto-save" checked onchange="toggleAutoSave(this.checked)">
                            Auto-Save Progress
                        </label>
                    </div>
                </div>
                <div class="field">
                    <label class="label">Performance Profile</label>
                    <div class="control">
                        <div class="select is-fullwidth">
                            <select id="performance-profile" onchange="updatePerformanceProfile(this.value)">
                                <option value="battery">Battery Saver</option>
                                <option value="balanced" selected>Balanced</option>
                                <option value="performance">High Performance</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Settings Actions -->
            <div class="field is-grouped is-grouped-right" style="margin-top: 24px;">
                <div class="control">
                    <button class="button" onclick="resetSettings()">Reset to Defaults</button>
                </div>
                <div class="control">
                    <button class="button is-primary" onclick="saveSettings()">Save Settings</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Developer Console -->
    <div id="dev-console" class="dev-console">
        <div class="console-header">
            <span>🔧 Developer Console</span>
            <div>
                <button class="button is-small is-dark" onclick="clearConsole()">Clear</button>
                <button class="button is-small is-dark" onclick="toggleConsole()">Close</button>
            </div>
        </div>
        <div id="console-output" class="console-output">
RC Sandbox Developer Console v1.0
Type 'help' for available commands.
        </div>
        <input id="console-input" class="console-input" type="text" placeholder="Enter command..." onkeypress="handleConsoleInput(event)">
    </div>

    <!-- Error Dialog -->
    <div id="error-dialog" class="error-dialog">
        <div class="error-title">⚠️ Application Error</div>
        <div id="error-message" class="error-message"></div>
        <div class="field is-grouped">
            <div class="control">
                <button class="button is-danger" onclick="reportError()">Report Bug</button>
            </div>
            <div class="control">
                <button class="button" onclick="closeErrorDialog()">Dismiss</button>
            </div>
            <div class="control">
                <button class="button is-warning" onclick="restartApp()">Restart App</button>
            </div>
        </div>
    </div>

    <!-- Loading Spinner -->
    <div id="loading-spinner" class="loading-spinner">
        <div class="spinner"></div>
    </div>

    <!-- Log Viewer -->
    <div id="log-viewer" class="log-viewer">
        <div class="log-header">
            <span>📋 System Logs</span>
            <div>
                <button class="button is-small is-dark" onclick="exportLogs()">Export</button>
                <button class="button is-small is-dark" onclick="clearLogs()">Clear</button>
                <button class="button is-small is-dark" onclick="toggleLogViewer()">Close</button>
            </div>
        </div>
        <div id="log-content" class="log-content"></div>
        <div class="log-controls">
            <label class="checkbox">
                <input type="checkbox" id="log-debug" checked onchange="updateLogFilter()">
                <span style="color: #888;">Debug</span>
            </label>
            <label class="checkbox">
                <input type="checkbox" id="log-info" checked onchange="updateLogFilter()">
                <span style="color: #00ff00;">Info</span>
            </label>
            <label class="checkbox">
                <input type="checkbox" id="log-warn" checked onchange="updateLogFilter()">
                <span style="color: #ffaa00;">Warn</span>
            </label>
            <label class="checkbox">
                <input type="checkbox" id="log-error" checked onchange="updateLogFilter()">
                <span style="color: #ff4444;">Error</span>
            </label>
        </div>
    </div>

    <!-- Telemetry Panel -->
    <div id="telemetry-panel" class="telemetry-panel">
        <div style="text-align: center; margin-bottom: 8px; color: #00ff00; font-weight: bold;">📊 TELEMETRY</div>
        <div class="telemetry-item">
            <span class="telemetry-label">Session:</span>
            <span class="telemetry-value" id="session-time">00:00:00</span>
        </div>
        <div class="telemetry-item">
            <span class="telemetry-label">FPS:</span>
            <span class="telemetry-value" id="telemetry-fps">60</span>
        </div>
        <div class="telemetry-item">
            <span class="telemetry-label">Memory:</span>
            <span class="telemetry-value" id="telemetry-memory">0MB</span>
        </div>
        <div class="telemetry-item">
            <span class="telemetry-label">Errors:</span>
            <span class="telemetry-value" id="telemetry-errors">0</span>
        </div>
        <div class="telemetry-item">
            <span class="telemetry-label">Warnings:</span>
            <span class="telemetry-value" id="telemetry-warnings">0</span>
        </div>
        <div class="telemetry-item">
            <span class="telemetry-label">Events:</span>
            <span class="telemetry-value" id="telemetry-events">0</span>
        </div>
        <div class="telemetry-item">
            <span class="telemetry-label">Vehicles:</span>
            <span class="telemetry-value" id="telemetry-vehicles">5</span>
        </div>
        <div class="telemetry-item">
            <span class="telemetry-label">Physics:</span>
            <span class="telemetry-value" id="telemetry-physics">ON</span>
        </div>
        <div class="telemetry-item">
            <span class="telemetry-label">Network:</span>
            <span class="telemetry-value" id="telemetry-network">LOCAL</span>
        </div>
    </div>

    <!-- Weather Panel -->
    <div id="weather-panel" class="weather-panel" style="position: fixed; top: 20px; right: 20px; z-index: 1000; display: none;">
        <div class="glass-panel" style="width: 280px; padding: 15px;">
            <div style="text-align: center; margin-bottom: 10px; color: #00d4ff; font-weight: bold;">🌦️ WEATHER CONTROL</div>

            <div class="weather-control-item">
                <label class="weather-label">Rain Intensity:</label>
                <input type="range" id="rain-slider" min="0" max="100" value="0" class="weather-slider">
                <span class="weather-value" id="rain-value">0%</span>
            </div>

            <div class="weather-control-item">
                <label class="weather-label">Wind Speed:</label>
                <input type="range" id="wind-speed" min="0" max="50" value="0" class="weather-slider">
                <span class="weather-value" id="wind-speed-value">0 m/s</span>
            </div>

            <div class="weather-control-item">
                <label class="weather-label">Wind Direction:</label>
                <input type="range" id="wind-direction" min="0" max="360" value="0" class="weather-slider">
                <span class="weather-value" id="wind-direction-value">0°</span>
            </div>

            <div class="weather-control-item">
                <label class="weather-label">Temperature:</label>
                <input type="range" id="temperature" min="-20" max="40" value="20" class="weather-slider">
                <span class="weather-value" id="temperature-value">20°C</span>
            </div>

            <div class="weather-control-item">
                <label class="weather-label">Humidity:</label>
                <input type="range" id="humidity" min="0" max="100" value="50" class="weather-slider">
                <span class="weather-value" id="humidity-value">50%</span>
            </div>

            <div style="margin-top: 15px; text-align: center;">
                <button class="glass-button" onclick="resetWeather()" style="margin-right: 10px;">🔄 Reset</button>
                <button class="glass-button" onclick="toggleWeatherPanel()">❌ Close</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Simple terrain simulation
        class TerrainEngine {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.cols = 100;
                this.rows = 75;
                this.heightMap = Array.from({length: this.rows}, () => Array(this.cols).fill(0.5));

                // Settings inspired by your demo
                this.settings = {
                    contourLines: true,
                    linesDistance: 0.1,
                    seaLevel: 0.4,
                    spatialFiltering: true,
                    quickReaction: false,
                    terrainType: 'islands',
                    colorTheme: 'topographic', // topographic, thermal, elevation, satellite
                    showLiveData: true,
                    displayKinectView: false
                };

                // Game state
                this.gameState = {
                    mode: 'terrain', // terrain, mission, fleet
                    score: 0,
                    timeLeft: 180,
                    status: 'active'
                };

                this.currentTool = 'raise';
                this.brushSize = 20;
                this.isDrawing = false;

                // Webcam height detection
                this.video = document.getElementById('video');
                this.baselineFrame = null;
                this.isCalibrated = false;
                this.depthSensitivity = 10;

                // 3D Camera
                this.cameraAngle = 0; // 0 = top-down, 45 = isometric
                this.is3D = false;

                this.setupEventListeners();
                this.resize();
                this.animate();
                this.initializeUI();
            }
            
            setupEventListeners() {
                window.addEventListener('resize', () => this.resize());
                
                this.canvas.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.isDrawing = true;
                    this.draw(e);
                    console.log('Mouse down at:', e.clientX, e.clientY);
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    e.preventDefault();
                    if (this.isDrawing) this.draw(e);
                });
                
                this.canvas.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    this.isDrawing = false;
                });

                // Right-click for lowering terrain
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    return false;
                });
                
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.brushSize = Math.max(5, Math.min(50, this.brushSize + (e.deltaY > 0 ? -2 : 2)));
                    document.getElementById('brush-size').textContent = this.brushSize;
                });
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        // Could close or reset
                    } else if (e.key === 'r' || e.key === 'R') {
                        this.resetTerrain();
                    } else if (e.key === 'c' || e.key === 'C') {
                        this.calibrateWebcam();
                    } else if (e.key === 'v' || e.key === 'V') {
                        this.toggle3D();
                    }
                });
                
                // Tool selection
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelector('.tool-btn.active').classList.remove('active');
                        btn.classList.add('active');
                        this.currentTool = btn.dataset.tool;
                    });
                });
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            draw(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                console.log('Drawing at canvas coords:', x, y, 'button:', e.button);
                
                const cellW = this.canvas.width / this.cols;
                const cellH = this.canvas.height / this.rows;
                const cx = Math.floor(x / cellW);
                const cy = Math.floor(y / cellH);
                const r = Math.ceil(this.brushSize / Math.min(cellW, cellH));
                
                // Check if voxel mode is enabled
                if (this.voxelEnabled && e.shiftKey) {
                    // Voxel construction mode (Shift + Click)
                    if (e.button === 0) { // Left click - place voxel
                        this.placeVoxelAt(x, y);
                    } else if (e.button === 2) { // Right click - remove voxel
                        this.removeVoxelAt(x, y);
                    }
                } else {
                    // Normal terrain modification
                    for (let dy = -r; dy <= r; dy++) {
                        for (let dx = -r; dx <= r; dx++) {
                            const nx = cx + dx, ny = cy + dy;
                            if (nx >= 0 && nx < this.cols && ny >= 0 && ny < this.rows) {
                                const dist = Math.hypot(dx, dy);
                                if (dist <= r) {
                                    const falloff = 1 - (dist / r);
                                    const delta = 0.02 * falloff;

                                    if (this.currentTool === 'raise' || e.button === 0) {
                                        this.heightMap[ny][nx] = Math.min(1, this.heightMap[ny][nx] + delta);
                                    } else if (this.currentTool === 'lower' || e.button === 2) {
                                        this.heightMap[ny][nx] = Math.max(0, this.heightMap[ny][nx] - delta);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            resetTerrain() {
                this.heightMap = Array.from({length: this.rows}, () => Array(this.cols).fill(0.5));
                console.log('🔄 Terrain reset to baseline');
            }

            // Alias for resetTerrain to match button calls
            reset() {
                this.resetTerrain();
                console.log('🔄 Terrain reset via reset() method');
            }

            // Add water at specific coordinates
            addWaterAt(canvasX, canvasY, intensity = 0.3) {
                // Convert canvas coordinates to terrain grid coordinates
                const gridX = Math.floor((canvasX / this.canvas.width) * this.cols);
                const gridY = Math.floor((canvasY / this.canvas.height) * this.rows);

                console.log(`💧 Adding water at grid position: ${gridX}, ${gridY}`);

                // Add water in a circular area
                const radius = 5;
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist <= radius) {
                            const x = gridX + dx;
                            const y = gridY + dy;

                            if (x >= 0 && x < this.cols && y >= 0 && y < this.rows) {
                                // Lower terrain to create water
                                const waterLevel = intensity * (1 - dist/radius);
                                this.heightMap[y][x] = Math.min(this.heightMap[y][x], waterLevel);
                            }
                        }
                    }
                }

                console.log('💧 Water added successfully');
            }

            // Physics simulation methods
            enablePhysicsSimulation() {
                this.enablePhysics = true;
                console.log('⚛️ Physics simulation enabled');
            }

            disablePhysicsSimulation() {
                this.enablePhysics = false;
                console.log('⚛️ Physics simulation disabled');
            }

            calibrateWebcam() {
                if (!this.video || this.video.readyState !== this.video.HAVE_ENOUGH_DATA) {
                    console.log('❌ No webcam feed available');
                    return;
                }

                console.log('🎯 Calibrating webcam...');

                // Capture baseline frame
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.cols;
                tempCanvas.height = this.rows;

                tempCtx.drawImage(this.video, 0, 0, this.cols, this.rows);
                this.baselineFrame = tempCtx.getImageData(0, 0, this.cols, this.rows);

                this.isCalibrated = true;
                console.log('✅ Webcam calibrated! Move hand closer to create mountains');
            }

            toggle3D() {
                this.is3D = !this.is3D;
                this.cameraAngle = this.is3D ? 45 : 0;
                console.log(`📐 Switched to ${this.is3D ? '3D Isometric' : 'Top-Down'} view`);
            }

            startFloodDefense() {
                console.log('🌊 Starting Flood Defense Mission!');

                // Create some pre-dug moats for the mission
                const centerX = Math.floor(this.cols / 2);
                const centerY = Math.floor(this.rows / 2);

                // Dig defensive moats
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                    const radius = 15;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;

                    // Create moat sections
                    for (let i = -3; i <= 3; i++) {
                        for (let j = -2; j <= 2; j++) {
                            const mx = Math.floor(x + i);
                            const my = Math.floor(y + j);

                            if (mx >= 0 && mx < this.cols && my >= 0 && my < this.rows) {
                                this.heightMap[my][mx] = 0.2; // Water level
                            }
                        }
                    }
                }

                // Add some hills to defend
                for (let i = 0; i < 3; i++) {
                    const hx = Math.floor(Math.random() * this.cols);
                    const hy = Math.floor(Math.random() * this.rows);

                    for (let dy = -5; dy <= 5; dy++) {
                        for (let dx = -5; dx <= 5; dx++) {
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist <= 5) {
                                const nx = hx + dx;
                                const ny = hy + dy;

                                if (nx >= 0 && nx < this.cols && ny >= 0 && ny < this.rows) {
                                    const height = 0.8 + (1 - dist/5) * 0.2;
                                    this.heightMap[ny][nx] = Math.max(this.heightMap[ny][nx], height);
                                }
                            }
                        }
                    }
                }

                document.getElementById('mode').textContent = 'FLOOD DEFENSE';

                // Show mission notification
                this.showNotification('🌊 Flood Defense Mission Started! Fill the moats before the flood arrives!');
            }

            showNotification(message) {
                // Create notification element
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 100px;
                    right: 20px;
                    background: rgba(76, 175, 80, 0.9);
                    color: white;
                    padding: 15px 20px;
                    border-radius: 8px;
                    font-weight: bold;
                    z-index: 1000;
                    max-width: 300px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    animation: slideIn 0.3s ease;
                `;
                notification.textContent = message;

                // Add animation keyframes
                if (!document.getElementById('notification-styles')) {
                    const style = document.createElement('style');
                    style.id = 'notification-styles';
                    style.textContent = `
                        @keyframes slideIn {
                            from { transform: translateX(100%); opacity: 0; }
                            to { transform: translateX(0); opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }

                document.body.appendChild(notification);

                // Remove after 4 seconds
                setTimeout(() => {
                    notification.style.animation = 'slideIn 0.3s ease reverse';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, 4000);
            }

            // Toast notification system (inspired by your demo)
            showToast(message, type = 'info') {
                const toast = document.createElement('div');
                toast.className = `toast toast-${type}`;
                toast.innerHTML = `
                    <div class="toast-content">
                        <span class="toast-icon">${this.getToastIcon(type)}</span>
                        <span class="toast-message">${message}</span>
                    </div>
                `;

                document.body.appendChild(toast);

                // Animate in
                setTimeout(() => toast.classList.add('toast-show'), 100);

                // Remove after 3 seconds
                setTimeout(() => {
                    toast.classList.remove('toast-show');
                    setTimeout(() => document.body.removeChild(toast), 300);
                }, 3000);
            }

            getToastIcon(type) {
                const icons = {
                    success: '✅',
                    error: '❌',
                    warning: '⚠️',
                    info: 'ℹ️'
                };
                return icons[type] || icons.info;
            }

            // Initialize UI controls (inspired by your demo structure)
            initializeUI() {
                this.setupToolButtons();
                this.setupModeControls();
                this.showToast('AR Sandbox initialized successfully!', 'success');
            }

            setupToolButtons() {
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentTool = btn.dataset.tool;
                        this.showToast(`Tool switched to: ${this.currentTool}`, 'info');
                    });
                });
            }

            setupModeControls() {
                // Add mode switching functionality
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        this.switchMode();
                    }
                });
            }

            switchMode() {
                const modes = ['terrain', 'mission', 'fleet'];
                const currentIndex = modes.indexOf(this.gameState.mode);
                const nextIndex = (currentIndex + 1) % modes.length;
                this.gameState.mode = modes[nextIndex];

                this.showToast(`Switched to ${this.gameState.mode.toUpperCase()} mode`, 'info');
                this.updateModeDisplay();
            }

            updateModeDisplay() {
                const modeElement = document.getElementById('current-mode');
                if (modeElement) {
                    modeElement.textContent = this.gameState.mode.toUpperCase();
                    // Change color based on mode
                    const colors = {
                        terrain: '#4CAF50',
                        mission: '#FF9800',
                        fleet: '#2196F3'
                    };
                    modeElement.style.color = colors[this.gameState.mode] || '#4CAF50';
                }
            }

            getMagicSandColor(height) {
                // Magic Sand HeightColorMap.xml data - normalized to 0-1 range
                const colorMap = [
                    { height: 0.0, color: [8, 48, 107] },     // Deep water - dark blue
                    { height: 0.1, color: [8, 81, 156] },     // Water - blue
                    { height: 0.2, color: [33, 113, 181] },   // Shallow water - light blue
                    { height: 0.3, color: [66, 146, 198] },   // Very shallow - cyan
                    { height: 0.4, color: [107, 174, 214] },  // Shore - light cyan
                    { height: 0.45, color: [158, 202, 225] }, // Beach - very light blue
                    { height: 0.5, color: [49, 163, 84] },    // Sea level - green
                    { height: 0.6, color: [116, 196, 118] },  // Low land - light green
                    { height: 0.7, color: [161, 217, 155] },  // Plains - pale green
                    { height: 0.75, color: [199, 233, 192] }, // Hills - very pale green
                    { height: 0.8, color: [237, 248, 177] },  // Foothills - yellow-green
                    { height: 0.85, color: [255, 255, 204] }, // Low mountains - pale yellow
                    { height: 0.9, color: [255, 237, 160] },  // Mountains - yellow
                    { height: 0.95, color: [254, 204, 92] },  // High mountains - orange
                    { height: 1.0, color: [240, 59, 32] }     // Peaks - red
                ];

                // Find interpolation range
                for (let i = 0; i < colorMap.length - 1; i++) {
                    const current = colorMap[i];
                    const next = colorMap[i + 1];

                    if (height >= current.height && height <= next.height) {
                        const t = (height - current.height) / (next.height - current.height);
                        return [
                            Math.round(current.color[0] + (next.color[0] - current.color[0]) * t),
                            Math.round(current.color[1] + (next.color[1] - current.color[1]) * t),
                            Math.round(current.color[2] + (next.color[2] - current.color[2]) * t)
                        ];
                    }
                }

                return height < 0.5 ? [0, 0, 80] : [255, 255, 255];
            }

            applyDiffusion() {
                // Simple diffusion simulation for realistic terrain flow
                const newHeightMap = this.heightMap.map(row => [...row]);
                const diffusionRate = 0.001;

                for (let y = 1; y < this.rows - 1; y++) {
                    for (let x = 1; x < this.cols - 1; x++) {
                        const current = this.heightMap[y][x];
                        let totalFlow = 0;
                        let flowCount = 0;

                        // Check all 8 neighbors
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;

                                const neighbor = this.heightMap[y + dy][x + dx];
                                if (neighbor < current) {
                                    const heightDiff = current - neighbor;
                                    totalFlow += heightDiff * diffusionRate;
                                    flowCount++;
                                }
                            }
                        }

                        if (flowCount > 0) {
                            newHeightMap[y][x] = Math.max(0, current - totalFlow / flowCount);
                        }
                    }
                }

                this.heightMap = newHeightMap;
            }

            renderContourLines() {
                // Draw professional topographic contour lines
                this.ctx.strokeStyle = 'rgba(139, 69, 19, 0.7)'; // Brown contour lines
                this.ctx.lineWidth = 1.5;

                const cellW = this.canvas.width / this.cols;
                const cellH = this.canvas.height / this.rows;
                const contourInterval = 0.1;

                for (let level = 0; level <= 1; level += contourInterval) {
                    this.ctx.beginPath();

                    for (let y = 0; y < this.rows - 1; y++) {
                        for (let x = 0; x < this.cols - 1; x++) {
                            const h1 = this.heightMap[y][x];
                            const h2 = this.heightMap[y][x + 1];
                            const h3 = this.heightMap[y + 1][x];

                            // Check for contour line crossing
                            if ((h1 <= level && h2 >= level) || (h1 >= level && h2 <= level)) {
                                const t = (level - h1) / (h2 - h1);
                                const screenX = (x + t) * cellW;
                                const screenY = y * cellH;
                                this.ctx.moveTo(screenX, screenY);
                                this.ctx.lineTo(screenX, screenY + cellH);
                            }

                            if ((h1 <= level && h3 >= level) || (h1 >= level && h3 <= level)) {
                                const t = (level - h1) / (h3 - h1);
                                const screenX = x * cellW;
                                const screenY = (y + t) * cellH;
                                this.ctx.moveTo(screenX, screenY);
                                this.ctx.lineTo(screenX + cellW, screenY);
                            }
                        }
                    }

                    this.ctx.stroke();
                }
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Apply diffusion every few frames for performance
                if (this.frameCount % 5 === 0) {
                    this.applyDiffusion();
                }
                this.frameCount = (this.frameCount || 0) + 1;

                if (this.is3D) {
                    this.render3D();
                } else {
                    this.renderTopDown();
                }
            }

            renderTopDown() {
                const cellW = this.canvas.width / this.cols;
                const cellH = this.canvas.height / this.rows;

                // Render terrain with simple rectangles
                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        const height = this.heightMap[y][x];
                        const [r, g, b] = this.getMagicSandColor(height);

                        this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        this.ctx.globalAlpha = 0.6;
                        this.ctx.fillRect(x * cellW, y * cellH, cellW, cellH);
                    }
                }
            }

            render3D() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;

                // Simple isometric projection
                for (let y = this.rows - 1; y >= 0; y--) {
                    for (let x = 0; x < this.cols; x++) {
                        const height = this.heightMap[y][x];
                        const [r, g, b] = this.getMagicSandColor(height);

                        // Isometric transformation
                        const isoX = (x - y) * 3;
                        const isoY = (x + y) * 1.5 - height * 50;

                        const screenX = centerX + isoX;
                        const screenY = centerY + isoY;

                        this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        this.ctx.globalAlpha = 0.8;
                        this.ctx.fillRect(screenX - 2, screenY - 2, 4, 4);
                    }
                }

                this.ctx.globalAlpha = 1;

                // Render contour lines (only in top-down view)
                if (!this.is3D) {
                    this.renderContourLines();
                }

                // Update FPS counter
                const now = performance.now();
                if (this.lastFrameTime) {
                    const fps = Math.round(1000 / (now - this.lastFrameTime));
                    document.getElementById('fps').textContent = fps;
                }
                this.lastFrameTime = now;
            }
            
            animate() {
                // Webcam height detection
                if (this.isCalibrated && this.baselineFrame && this.video.readyState === this.video.HAVE_ENOUGH_DATA) {
                    this.updateHeightFromWebcam();
                }

                this.render();
                requestAnimationFrame(() => this.animate());
            }

            updateHeightFromWebcam() {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.cols;
                tempCanvas.height = this.rows;

                tempCtx.drawImage(this.video, 0, 0, this.cols, this.rows);
                const currentFrame = tempCtx.getImageData(0, 0, this.cols, this.rows);

                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        const i = (y * this.cols + x) * 4;

                        // Calculate brightness difference
                        const currentBright = (currentFrame.data[i] + currentFrame.data[i+1] + currentFrame.data[i+2]) / 3;
                        const baseBright = (this.baselineFrame.data[i] + this.baselineFrame.data[i+1] + this.baselineFrame.data[i+2]) / 3;

                        const diff = Math.abs(currentBright - baseBright);

                        // SIMPLE: Big difference = hand close = high terrain
                        if (diff > 25) {
                            const targetHeight = 0.6 + (diff / 255) * (this.depthSensitivity / 10);
                            this.heightMap[y][x] = this.heightMap[y][x] * 0.8 + targetHeight * 0.2;
                        } else {
                            // Slowly return to base level
                            this.heightMap[y][x] = this.heightMap[y][x] * 0.99 + 0.5 * 0.01;
                        }
                    }
                }
            }
        }
        
        // ===== SAFE INITIALIZATION =====
        let terrain = null;

        function initializeApplication() {
            try {
                console.log('🚀 Initializing RC Sandbox...');

                // Check if required DOM elements exist
                const requiredElements = ['canvas', 'video', 'canvas3d'];
                const missing = requiredElements.filter(id => !document.getElementById(id));

                if (missing.length > 0) {
                    throw new Error(`Missing required elements: ${missing.join(', ')}`);
                }

                // Initialize webcam
                navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        const video = document.getElementById('video');
                        if (video) {
                            video.srcObject = stream;
                            console.log('📹 Webcam initialized');
                        }
                    })
                    .catch(error => {
                        console.warn('📹 Webcam not available:', error);
                        showNotification('📹 Webcam not available - using mouse input only', 'warning', 5000);
                    });

                // Initialize professional terrain engine with cartographic features
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    // Set canvas size for proper rendering
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;

                    terrain = new TerrainEngine(canvas);

                    // Initialize with professional topographic visualization
                    if (terrain.setRenderMode) {
                        terrain.setRenderMode('topographic');
                    }
                    if (terrain.generateInitialTerrain) {
                        terrain.generateInitialTerrain();
                    }

                    console.log('Professional terrain engine initialized');
                    window.logger?.info('Terrain engine initialized', {
                        width: canvas.width,
                        height: canvas.height,
                        mode: 'topographic'
                    }, 'TERRAIN');
                } else {
                    throw new Error('Canvas element not found');
                }

                // Make terrain globally accessible
                window.terrain = terrain;

                // Initialize 3D visualization
                setTimeout(() => {
                    if (init3D()) {
                        console.log('🎮 3D visualization initialized');
                    }
                }, 100); // Small delay to ensure terrain is ready

                // Initialize museum experience
                setTimeout(() => {
                    try {
                        initMuseumExperience();
                        console.log('🏛️ Museum experience initialized');
                    } catch (error) {
                        console.warn('🏛️ Museum experience failed:', error);
                    }
                }, 200);

                console.log('✅ RC Sandbox initialization complete');

                // Add button functionality test and visual feedback
                setTimeout(() => {
                    console.log('🔧 Testing button functionality...');
                    console.log('- Physics button function:', typeof togglePhysics);
                    console.log('- Water button function:', typeof addWater);
                    console.log('- Reset button function:', typeof resetSandbox);
                    console.log('- Terrain object exists:', !!window.terrain);

                    if (window.terrain) {
                        console.log('✅ All systems operational - buttons should work!');
                        showNotification('✅ All systems ready! Try clicking the buttons now.', 'success', 4000);

                        // Test terrain functionality
                        if (typeof window.terrain.addWaterAt === 'function') {
                            console.log('✅ Terrain water function available');
                        }
                        if (typeof window.terrain.reset === 'function') {
                            console.log('✅ Terrain reset function available');
                        }
                    } else {
                        console.warn('⚠️ Terrain object not found - buttons may not work');
                        showNotification('⚠️ Terrain system not ready - please refresh page', 'warning', 5000);
                    }
                }, 1000);

            } catch (error) {
                console.error('❌ Initialization failed:', error);
                showError('Initialization Failed', 'The application failed to start properly.', error);
            }
        }

        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApplication);
        } else {
            initializeApplication();
        }

        // Initialize Three.js 3D visualization
        let scene3d, camera3d, renderer3d, terrainMesh3d;

        function init3D() {
            try {
                console.log('🎮 Initializing Three.js 3D visualization...');

                // Check if Three.js is available
                if (typeof THREE === 'undefined') {
                    console.warn('Three.js not loaded, skipping 3D initialization');
                    return false;
                }

                // Check if canvas exists
                const canvas3d = document.getElementById('canvas3d');
                if (!canvas3d) {
                    console.warn('3D canvas not found, skipping 3D initialization');
                    return false;
                }

                // Create scene
                scene3d = new THREE.Scene();
                scene3d.background = new THREE.Color(0x000000);
                scene3d.fog = new THREE.Fog(0x000000, 50, 200);

                // Create camera
                camera3d = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera3d.position.set(50, 30, 50);
                camera3d.lookAt(0, 0, 0);

                // Create renderer
                renderer3d = new THREE.WebGLRenderer({ canvas: canvas3d, alpha: true });
                renderer3d.setSize(window.innerWidth, window.innerHeight);
                renderer3d.shadowMap.enabled = true;
                renderer3d.shadowMap.type = THREE.PCFSoftShadowMap;

                // Create terrain geometry
                const geometry = new THREE.PlaneGeometry(100, 75, terrain.cols - 1, terrain.rows - 1);
                geometry.rotateX(-Math.PI / 2); // Make it horizontal

                // Create terrain material
                const material = new THREE.MeshLambertMaterial({
                    color: 0x8B4513,
                    wireframe: false,
                    transparent: true,
                    opacity: 0.8
                });

                terrainMesh3d = new THREE.Mesh(geometry, material);
                terrainMesh3d.receiveShadow = true;
                scene3d.add(terrainMesh3d);

                // Add lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                scene3d.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 25);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene3d.add(directionalLight);

                // Add grid helper
                const gridHelper = new THREE.GridHelper(100, 50, 0x444444, 0x222222);
                scene3d.add(gridHelper);

                // Handle window resize
                window.addEventListener('resize', () => {
                    camera3d.aspect = window.innerWidth / window.innerHeight;
                    camera3d.updateProjectionMatrix();
                    renderer3d.setSize(window.innerWidth, window.innerHeight);
                });

                console.log('✅ Three.js 3D visualization initialized!');
                return true;

            } catch (error) {
                console.error('❌ Three.js initialization failed:', error);
                return false;
            }
        }

        // Update 3D terrain from 2D heightmap
        function update3DTerrain() {
            if (!terrainMesh3d || !terrain.heightMap) return;

            try {
                const vertices = terrainMesh3d.geometry.attributes.position.array;

                for (let y = 0; y < terrain.rows; y++) {
                    for (let x = 0; x < terrain.cols; x++) {
                        const index = (y * terrain.cols + x) * 3;
                        const height = terrain.heightMap[y][x] * 20; // Scale height
                        vertices[index + 1] = height; // Y is up in Three.js
                    }
                }

                terrainMesh3d.geometry.attributes.position.needsUpdate = true;
                terrainMesh3d.geometry.computeVertexNormals();

            } catch (error) {
                console.warn('3D terrain update error:', error);
            }
        }

        // 3D render loop
        function animate3D() {
            if (renderer3d && scene3d && camera3d) {
                // Rotate camera around terrain
                const time = Date.now() * 0.0005;
                camera3d.position.x = Math.cos(time) * 60;
                camera3d.position.z = Math.sin(time) * 60;
                camera3d.lookAt(0, 0, 0);

                // Update 3D terrain
                update3DTerrain();

                // Render
                renderer3d.render(scene3d, camera3d);
            }

            requestAnimationFrame(animate3D);
        }

        // Initialize 3D visualization
        if (typeof THREE !== 'undefined') {
            init3D();
            animate3D();
        } else {
            console.warn('⚠️ Three.js not available, using 2D visualization only');
        }

        // Voxel construction functions
        function setupVoxelControls() {
            const voxelModeSelect = document.getElementById('voxel-mode');
            const voxelMaterialSelect = document.getElementById('voxel-material');
            const voxelBrushSlider = document.getElementById('voxel-brush');
            const voxelBrushValue = document.getElementById('voxel-brush-value');

            voxelModeSelect.addEventListener('change', (e) => {
                if (terrain.setVoxelMode) {
                    terrain.setVoxelMode(e.target.value);
                }
            });

            voxelMaterialSelect.addEventListener('change', (e) => {
                if (terrain.setVoxelMaterial) {
                    terrain.setVoxelMaterial(e.target.value);
                }
            });

            voxelBrushSlider.addEventListener('input', (e) => {
                const size = parseInt(e.target.value);
                voxelBrushValue.textContent = size + ' block' + (size > 1 ? 's' : '');
                if (terrain.setVoxelBrushSize) {
                    terrain.setVoxelBrushSize(size);
                }
            });

            // Update voxel stats periodically - FIXED MEMORY LEAK
            const voxelStatsId = setInterval(updateVoxelStats, 1000);
            if (!window.intervalIds) window.intervalIds = [];
            window.intervalIds.push(voxelStatsId);
        }

        function toggleVoxelMode() {
            const btn = document.getElementById('voxel-toggle-btn');
            if (terrain.voxelEnabled) {
                terrain.voxelEnabled = false;
                btn.textContent = '🧱 VOXEL OFF';
                btn.style.background = '#666';
            } else {
                terrain.voxelEnabled = true;
                btn.textContent = '🧱 VOXEL ON';
                btn.style.background = '#4CAF50';
            }
        }

        function clearVoxels() {
            if (terrain.clearVoxels && confirm('Clear all voxel constructions?')) {
                terrain.clearVoxels();
                updateVoxelStats();
            }
        }

        function exportVoxels() {
            if (terrain.exportVoxelData) {
                const data = terrain.exportVoxelData();
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'voxel_construction.json';
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        function importVoxels() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        if (terrain.importVoxelData) {
                            terrain.importVoxelData(e.target.result);
                            updateVoxelStats();
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function updateVoxelStats() {
            if (terrain.getVoxelStats) {
                const stats = terrain.getVoxelStats();
                document.getElementById('voxel-count').textContent = stats.totalVoxels;
                document.getElementById('chunk-count').textContent = stats.chunks;
            }
        }

        // Museum Experience functions
        let museumExperience = {
            enabled: false,
            shaderBackground: null,
            creativeSketch: null,
            currentStyle: 'topographic',
            activeEffects: new Set(),
            animationSpeed: 1.0,
            colorPalette: 'earth'
        };

        function setupMuseumExperience() {
            try {
                console.log('🎨 Initializing Museum Experience...');

                // Initialize shader background
                initShaderBackground();

                // Initialize creative coding overlay
                initCreativeOverlay();

                // Setup event listeners
                setupMuseumControls();

                console.log('✅ Museum Experience initialized');
            } catch (error) {
                console.error('❌ Museum Experience initialization failed:', error);
            }
        }

        function initShaderBackground() {
            try {
                if (typeof shaderWebBackground !== 'undefined') {
                    const canvas = document.getElementById('shader-background');

                    museumExperience.shaderBackground = shaderWebBackground.shaderWebBackground({
                        canvas: canvas,
                        fallbackImage: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZGVmcz48bGluZWFyR3JhZGllbnQgaWQ9ImciIHgxPSIwJSIgeTE9IjAlIiB4Mj0iMTAwJSIgeTI9IjEwMCUiPjxzdG9wIG9mZnNldD0iMCUiIHN0b3AtY29sb3I9IiM2NjdlZWEiLz48c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiM3NjRiYTIiLz48L2xpbmVhckdyYWRpZW50PjwvZGVmcz48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0idXJsKCNnKSIvPjwvc3ZnPg==',
                        shaders: {
                            waves: {
                                uniforms: {
                                    u_time: { type: 'float', value: 0 },
                                    u_resolution: { type: 'vec2', value: [window.innerWidth, window.innerHeight] },
                                    u_mouse: { type: 'vec2', value: [0, 0] }
                                },
                                fragment: `
                                    precision mediump float;
                                    uniform float u_time;
                                    uniform vec2 u_resolution;
                                    uniform vec2 u_mouse;

                                    void main() {
                                        vec2 st = gl_FragCoord.xy / u_resolution.xy;
                                        vec3 color = vec3(0.0);

                                        // Create flowing waves
                                        float wave1 = sin(st.x * 10.0 + u_time * 2.0) * 0.1;
                                        float wave2 = sin(st.y * 8.0 + u_time * 1.5) * 0.1;
                                        float combined = wave1 + wave2;

                                        // Topographic-inspired colors
                                        color = vec3(0.2 + combined, 0.4 + combined * 0.5, 0.1 + combined * 0.3);

                                        gl_FragColor = vec4(color, 0.8);
                                    }
                                `
                            }
                        }
                    });

                    console.log('✅ Shader background initialized');
                } else {
                    console.warn('⚠️ Shader Web Background not available');
                }
            } catch (error) {
                console.error('Shader background error:', error);
            }
        }

        function initCreativeOverlay() {
            try {
                if (typeof p5 !== 'undefined') {
                    // Create p5.js sketch for creative overlay
                    const sketch = (p) => {
                        let particles = [];

                        p.setup = () => {
                            const canvas = p.createCanvas(window.innerWidth, window.innerHeight);
                            canvas.parent('creative-overlay');

                            // Initialize particles
                            for (let i = 0; i < 50; i++) {
                                particles.push({
                                    x: p.random(p.width),
                                    y: p.random(p.height),
                                    vx: p.random(-1, 1),
                                    vy: p.random(-1, 1),
                                    size: p.random(2, 8),
                                    alpha: p.random(50, 150)
                                });
                            }
                        };

                        p.draw = () => {
                            p.clear();

                            if (museumExperience.activeEffects.has('particles')) {
                                // Draw and update particles
                                particles.forEach(particle => {
                                    p.fill(100, 150, 255, particle.alpha);
                                    p.noStroke();
                                    p.ellipse(particle.x, particle.y, particle.size);

                                    // Update position
                                    particle.x += particle.vx * museumExperience.animationSpeed;
                                    particle.y += particle.vy * museumExperience.animationSpeed;

                                    // Wrap around screen
                                    if (particle.x < 0) particle.x = p.width;
                                    if (particle.x > p.width) particle.x = 0;
                                    if (particle.y < 0) particle.y = p.height;
                                    if (particle.y > p.height) particle.y = 0;
                                });
                            }

                            if (museumExperience.activeEffects.has('trails')) {
                                // Draw mouse trails
                                p.stroke(255, 100, 150, 100);
                                p.strokeWeight(3);
                                p.line(p.pmouseX, p.pmouseY, p.mouseX, p.mouseY);
                            }
                        };

                        p.windowResized = () => {
                            p.resizeCanvas(window.innerWidth, window.innerHeight);
                        };
                    };

                    museumExperience.creativeSketch = new p5(sketch);
                    console.log('✅ Creative overlay initialized');
                } else {
                    console.warn('⚠️ p5.js not available');
                }
            } catch (error) {
                console.error('Creative overlay error:', error);
            }
        }

        function setupMuseumControls() {
            const visualStyleSelect = document.getElementById('visual-style');
            const shaderTypeSelect = document.getElementById('shader-type');
            const animationSpeedSlider = document.getElementById('animation-speed');
            const speedValue = document.getElementById('speed-value');

            visualStyleSelect.addEventListener('change', (e) => {
                setVisualStyle(e.target.value);
            });

            shaderTypeSelect.addEventListener('change', (e) => {
                setShaderType(e.target.value);
            });

            animationSpeedSlider.addEventListener('input', (e) => {
                const speed = parseFloat(e.target.value);
                museumExperience.animationSpeed = speed;
                speedValue.textContent = speed.toFixed(1) + 'x';
            });
        }

        function setVisualStyle(style) {
            museumExperience.currentStyle = style;
            document.getElementById('current-style').textContent = style.charAt(0).toUpperCase() + style.slice(1);

            // Apply visual style changes to terrain rendering
            if (terrain && terrain.setVisualStyle) {
                terrain.setVisualStyle(style);
            }

            console.log(`🎨 Visual style changed to: ${style}`);
        }

        function setShaderType(type) {
            // Update shader background type
            console.log(`🌊 Shader type changed to: ${type}`);
        }

        function toggleCreativeEffect(effect) {
            const btn = document.getElementById(effect + '-btn');

            if (museumExperience.activeEffects.has(effect)) {
                museumExperience.activeEffects.delete(effect);
                btn.style.background = '#666';
            } else {
                museumExperience.activeEffects.add(effect);
                btn.style.background = '#4CAF50';
            }

            updateActiveEffectsDisplay();
        }

        function setColorPalette(palette) {
            museumExperience.colorPalette = palette;
            console.log(`🎨 Color palette changed to: ${palette}`);
        }

        function toggleMuseumMode() {
            const btn = document.getElementById('museum-toggle-btn');

            if (museumExperience.enabled) {
                museumExperience.enabled = false;
                btn.textContent = '🏛️ MUSEUM OFF';
                btn.style.background = '#666';

                // Hide creative elements
                document.getElementById('shader-background').style.opacity = '0';
                document.getElementById('creative-overlay').style.opacity = '0';
            } else {
                museumExperience.enabled = true;
                btn.textContent = '🏛️ MUSEUM ON';
                btn.style.background = '#9C27B0';

                // Show creative elements
                document.getElementById('shader-background').style.opacity = '0.3';
                document.getElementById('creative-overlay').style.opacity = '0.2';
            }
        }

        function captureArtwork() {
            try {
                // Capture the current canvas as artwork
                const canvas = document.getElementById('canvas');
                const link = document.createElement('a');
                link.download = `ar-sandbox-artwork-${Date.now()}.png`;
                link.href = canvas.toDataURL();
                link.click();

                console.log('📸 Artwork captured');
            } catch (error) {
                console.error('Capture error:', error);
            }
        }

        function updateActiveEffectsDisplay() {
            const effectsArray = Array.from(museumExperience.activeEffects);
            const display = effectsArray.length > 0 ? effectsArray.join(', ') : 'None';
            document.getElementById('active-effects').textContent = display;
        }

        // Weather control functions - FIXED NULL SAFETY
        function setupWeatherControls() {
            const rainSlider = document.getElementById('rain-slider');
            const rainValue = document.getElementById('rain-value');
            const windSpeedSlider = document.getElementById('wind-speed');
            const windSpeedValue = document.getElementById('wind-speed-value');
            const windDirectionSlider = document.getElementById('wind-direction');
            const windDirectionValue = document.getElementById('wind-direction-value');
            const temperatureSlider = document.getElementById('temperature');
            const temperatureValue = document.getElementById('temperature-value');
            const humiditySlider = document.getElementById('humidity');
            const humidityValue = document.getElementById('humidity-value');

            // Rain controls
            if (rainSlider && rainValue) {
                rainSlider.addEventListener('input', (e) => {
                    const intensity = parseInt(e.target.value) / 100;
                    rainValue.textContent = e.target.value + '%';

                    if (window.terrain && terrain.startRain) {
                        if (intensity > 0) {
                            terrain.startRain(intensity);
                        } else {
                            terrain.stopRain();
                        }
                    }
                });
            }

            // Wind speed controls
            if (windSpeedSlider && windSpeedValue) {
                windSpeedSlider.addEventListener('input', (e) => {
                    const speed = parseInt(e.target.value);
                    windSpeedValue.textContent = speed + ' m/s';

                    if (window.terrain && terrain.setWind && windDirectionSlider) {
                        const direction = parseInt(windDirectionSlider.value);
                        terrain.setWind(speed, direction);
                    }
                });
            }

            // Wind direction controls
            if (windDirectionSlider && windDirectionValue) {
                windDirectionSlider.addEventListener('input', (e) => {
                    const direction = parseInt(e.target.value);
                    windDirectionValue.textContent = direction + '°';

                    if (window.terrain && terrain.setWind && windSpeedSlider) {
                        const speed = parseInt(windSpeedSlider.value);
                        terrain.setWind(speed, direction);
                    }
                });
            }

            // Temperature controls
            if (temperatureSlider && temperatureValue) {
                temperatureSlider.addEventListener('input', (e) => {
                    const temp = parseInt(e.target.value);
                    temperatureValue.textContent = temp + '°C';

                    if (window.terrain && terrain.setTemperature) {
                        terrain.setTemperature(temp);
                    }
                });
            }

            // Humidity controls
            if (humiditySlider && humidityValue) {
                humiditySlider.addEventListener('input', (e) => {
                    const humidity = parseInt(e.target.value);
                    humidityValue.textContent = humidity + '%';

                    if (window.terrain && terrain.setHumidity) {
                        terrain.setHumidity(humidity);
                    }
                });
            }
        }

        function togglePhysics() {
            console.log('🔧 Physics button clicked!');

            if (!window.terrain) {
                console.warn('⚠️ Terrain not available for physics toggle');
                showNotification('⚠️ Terrain system not ready', 'warning');
                return;
            }

            try {
                const btn = document.getElementById('physics-btn');
                if (terrain.enablePhysics) {
                    terrain.disablePhysicsSimulation();
                    if (btn) {
                        btn.textContent = '⚛️ PHYSICS OFF';
                        btn.style.background = '#FF5722';
                    }
                    showNotification('⚛️ Physics simulation disabled', 'info');
                    console.log('⚛️ Physics disabled');
                } else {
                    terrain.enablePhysicsSimulation();
                    if (btn) {
                        btn.textContent = '⚛️ PHYSICS ON';
                        btn.style.background = '#4CAF50';
                    }
                    showNotification('⚛️ Physics simulation enabled', 'success');
                    console.log('⚛️ Physics enabled');
                }
            } catch (error) {
                console.error('❌ Physics toggle failed:', error);
                showNotification('❌ Physics toggle failed', 'error');
            }
        }

        function addWater() {
            console.log('💧 Water button clicked!');

            if (!window.terrain) {
                console.warn('⚠️ Terrain not available for water');
                showNotification('⚠️ Terrain system not ready', 'warning');
                return;
            }

            try {
                // Add water at center of canvas
                const canvas = document.getElementById('canvas');
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                if (terrain.addWaterAt) {
                    terrain.addWaterAt(centerX, centerY, 0.2);
                    showNotification('💧 Water added at center!', 'success');
                    console.log('💧 Water added at:', centerX, centerY);
                } else {
                    console.warn('⚠️ addWaterAt function not available');
                    showNotification('💧 Water feature not available', 'warning');
                }
            } catch (error) {
                console.error('❌ Add water failed:', error);
                showNotification('❌ Failed to add water', 'error');
            }
        }

        // Initialize weather controls
        setupWeatherControls();

        // Modern UI Functions
        function showNotification(message, type = 'info', duration = 3000) {
            const container = document.getElementById('notification-container');
            const notification = document.createElement('div');

            let bgClass = 'is-info';
            let icon = 'ℹ️';

            switch(type) {
                case 'success':
                    bgClass = 'is-success';
                    icon = '✅';
                    break;
                case 'warning':
                    bgClass = 'is-warning';
                    icon = '⚠️';
                    break;
                case 'error':
                    bgClass = 'is-danger';
                    icon = '❌';
                    break;
            }

            notification.className = `notification ${bgClass} glass-panel`;
            notification.innerHTML = `
                <button class="delete" onclick="this.parentElement.remove()"></button>
                <strong>${icon} ${message}</strong>
            `;

            container.appendChild(notification);

            // Auto-remove after duration
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, duration);
        }

        function toggleAI() {
            // Toggle AI vehicle behaviors
            if (window.vehicleFleet) {
                window.vehicleFleet.aiEnabled = !window.vehicleFleet.aiEnabled;
                const status = window.vehicleFleet.aiEnabled ? 'enabled' : 'disabled';
                showNotification(`AI vehicles ${status}`, 'info');
            }
        }

        function addFire() {
            // Add fire element to terrain
            const canvas = document.getElementById('canvas');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            if (terrain) {
                // Add fire at center (implementation depends on terrain system)
                showNotification('🔥 Fire added to terrain', 'warning');
            }
        }

        function toggleWeather() {
            // Toggle weather effects
            if (window.weatherSystem) {
                window.weatherSystem.enabled = !window.weatherSystem.enabled;
                const status = window.weatherSystem.enabled ? 'enabled' : 'disabled';
                showNotification(`Weather effects ${status}`, 'info');
            } else {
                // Show weather panel if no weather system
                toggleWeatherPanel();
            }
        }

        function toggleWeatherPanel() {
            const panel = document.getElementById('weather-panel');
            if (panel) {
                const isVisible = panel.style.display !== 'none';
                panel.style.display = isVisible ? 'none' : 'block';

                if (!isVisible) {
                    showNotification('🌦️ Weather panel opened', 'info');
                } else {
                    showNotification('🌦️ Weather panel closed', 'info');
                }
            }
        }

        function resetWeather() {
            // Reset all weather controls to default values
            const controls = [
                { id: 'rain-slider', value: 0, display: 'rain-value', suffix: '%' },
                { id: 'wind-speed', value: 0, display: 'wind-speed-value', suffix: ' m/s' },
                { id: 'wind-direction', value: 0, display: 'wind-direction-value', suffix: '°' },
                { id: 'temperature', value: 20, display: 'temperature-value', suffix: '°C' },
                { id: 'humidity', value: 50, display: 'humidity-value', suffix: '%' }
            ];

            controls.forEach(control => {
                const slider = document.getElementById(control.id);
                const display = document.getElementById(control.display);

                if (slider && display) {
                    slider.value = control.value;
                    display.textContent = control.value + control.suffix;
                }
            });

            showNotification('🔄 Weather settings reset', 'success');
        }

        function resetSandbox() {
            console.log('🔄 Reset button clicked!');

            if (!window.terrain) {
                console.warn('⚠️ Terrain not available for reset');
                showNotification('⚠️ Terrain system not ready', 'warning');
                return;
            }

            try {
                // Reset the entire sandbox
                if (terrain.reset) {
                    terrain.reset();
                    showNotification('🔄 Sandbox reset successfully!', 'success');
                    console.log('🔄 Sandbox reset completed');
                } else {
                    console.warn('⚠️ Reset function not available');
                    showNotification('🔄 Reset feature not available', 'warning');
                }
            } catch (error) {
                console.error('❌ Reset failed:', error);
                showNotification('❌ Failed to reset sandbox', 'error');
            }
        }

        // Note: togglePhysics() is already defined above for terrain physics

        function saveState() {
            // Save current sandbox state
            try {
                const state = {
                    terrain: terrain ? terrain.getState() : null,
                    vehicles: window.vehicleFleet ? window.vehicleFleet.getState() : null,
                    timestamp: Date.now()
                };

                localStorage.setItem('rc-sandbox-state', JSON.stringify(state));
                showNotification('💾 State saved successfully', 'success');
            } catch (error) {
                showNotification('❌ Failed to save state', 'error');
            }
        }

        function changeMission(missionType) {
            // Change active mission
            const missions = {
                'sandbox': '🎨 Creative Sandbox Mode',
                'flood': '🌊 Flood Defense Emergency',
                'construction': '🏗️ Highway Construction',
                'racing': '🏁 Vehicle Racing Grand Prix',
                'cleanup': '♻️ Waste Cleanup Challenge'
            };

            const missionName = missions[missionType] || 'Unknown Mission';
            showNotification(`Mission changed: ${missionName}`, 'info');

            // Show mission progress panel
            const progressPanel = document.getElementById('mission-progress');
            if (missionType !== 'sandbox') {
                progressPanel.style.display = 'block';
                document.getElementById('mission-status').textContent = `Starting ${missionName}...`;
                document.getElementById('mission-progress-bar').value = 0;
            } else {
                progressPanel.style.display = 'none';
            }
        }

        function toggleHelp() {
            const helpOverlay = document.getElementById('help-overlay');
            const isVisible = helpOverlay.style.display === 'flex';
            helpOverlay.style.display = isVisible ? 'none' : 'flex';
        }

        // Update performance metrics
        function updateMetrics() {
            try {
                // Update FPS counter
                const fpsElement = document.getElementById('fps-counter');
                if (fpsElement && window.performance) {
                    // Simple FPS calculation
                    const fps = Math.round(1000 / (performance.now() - (window.lastFrameTime || performance.now())));
                    fpsElement.textContent = Math.min(fps, 60);
                    window.lastFrameTime = performance.now();
                }

                // Update vehicle count
                const vehicleElement = document.getElementById('vehicle-count');
                if (vehicleElement && window.vehicleFleet) {
                    vehicleElement.textContent = window.vehicleFleet.activeVehicles || 5;
                }

                // Update terrain points
                const terrainElement = document.getElementById('terrain-points');
                if (terrainElement && window.terrain) {
                    terrainElement.textContent = (window.terrain.cols * window.terrain.rows) || 1024;
                }
            } catch (error) {
                // Silently fail for metrics - don't spam console
                if (window.logger) {
                    window.logger.debug('Metrics update failed', { error: error.message }, 'METRICS');
                }
            }
        }

        // Note: Keyboard shortcuts are handled by the comprehensive handler below

        // Update metrics every second - FIXED MEMORY LEAK
        const metricsUpdateId = setInterval(updateMetrics, 1000);
        if (!window.intervalIds) window.intervalIds = [];
        window.intervalIds.push(metricsUpdateId);

        // ===== SETTINGS SYSTEM =====

        function openSettings() {
            const overlay = document.getElementById('settings-overlay');
            overlay.style.display = 'flex';
            overlay.classList.add('fade-in');
            showNotification('⚙️ Settings opened', 'info');
        }

        function closeSettings() {
            const overlay = document.getElementById('settings-overlay');
            overlay.style.display = 'none';
        }

        function switchSettingsTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.settings-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.settings-tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(tabName + '-tab').classList.add('active');
            event.target.classList.add('active');
        }

        function updateRenderQuality(quality) {
            window.appSettings.graphics.renderQuality = quality;
            showNotification(`🎨 Render quality set to ${quality}`, 'info');
            // Apply quality settings
            applyGraphicsSettings();
        }

        function updateFPSLimit(fps) {
            window.appSettings.graphics.fpsLimit = parseInt(fps);
            document.getElementById('fps-limit-value').textContent = fps + ' FPS';
            showNotification(`🎯 FPS limit set to ${fps}`, 'info');
        }

        function toggleShadows(enabled) {
            window.appSettings.graphics.shadows = enabled;
            showNotification(`💡 Shadows ${enabled ? 'enabled' : 'disabled'}`, 'info');
            applyGraphicsSettings();
        }

        function toggleParticles(enabled) {
            window.appSettings.graphics.particles = enabled;
            showNotification(`✨ Particles ${enabled ? 'enabled' : 'disabled'}`, 'info');
        }

        function updateMasterVolume(volume) {
            window.appSettings.audio.masterVolume = parseInt(volume);
            document.getElementById('master-volume-value').textContent = volume + '%';
            applyAudioSettings();
        }

        function updateSFXVolume(volume) {
            window.appSettings.audio.sfxVolume = parseInt(volume);
            document.getElementById('sfx-volume-value').textContent = volume + '%';
            applyAudioSettings();
        }

        function updateMusicVolume(volume) {
            window.appSettings.audio.musicVolume = parseInt(volume);
            document.getElementById('music-volume-value').textContent = volume + '%';
            applyAudioSettings();
        }

        function toggleTerrainAudio(enabled) {
            window.appSettings.audio.terrainAudio = enabled;
            showNotification(`🎵 Terrain audio ${enabled ? 'enabled' : 'disabled'}`, 'info');
        }

        function updateMouseSensitivity(sensitivity) {
            window.appSettings.controls.mouseSensitivity = parseFloat(sensitivity);
            document.getElementById('mouse-sensitivity-value').textContent = sensitivity + 'x';
        }

        function toggleInvertMouse(enabled) {
            window.appSettings.controls.invertMouse = enabled;
            showNotification(`🖱️ Mouse invert ${enabled ? 'enabled' : 'disabled'}`, 'info');
        }

        function toggleGestures(enabled) {
            window.appSettings.controls.gestures = enabled;
            showNotification(`👋 Gestures ${enabled ? 'enabled' : 'disabled'}`, 'info');
        }

        function toggleDebugMode(enabled) {
            window.appSettings.advanced.debugMode = enabled;
            if (enabled) {
                showNotification('🔧 Debug mode enabled', 'warning');
                document.getElementById('dev-console').style.display = 'flex';
            } else {
                showNotification('🔧 Debug mode disabled', 'info');
                document.getElementById('dev-console').style.display = 'none';
            }
        }

        function toggleTelemetry(enabled) {
            window.appSettings.advanced.telemetry = enabled;
            showNotification(`📊 Telemetry ${enabled ? 'enabled' : 'disabled'}`, 'info');
        }

        function toggleAutoSave(enabled) {
            window.appSettings.advanced.autoSave = enabled;
            showNotification(`💾 Auto-save ${enabled ? 'enabled' : 'disabled'}`, 'info');
        }

        function updatePerformanceProfile(profile) {
            window.appSettings.advanced.performanceProfile = profile;
            showNotification(`⚡ Performance profile: ${profile}`, 'info');
            applyPerformanceProfile(profile);
        }

        function resetSettings() {
            if (confirm('Reset all settings to defaults?')) {
                initializeDefaultSettings();
                loadSettingsIntoUI();
                showNotification('🔄 Settings reset to defaults', 'success');
            }
        }

        function saveSettings() {
            try {
                localStorage.setItem('rc-sandbox-settings', JSON.stringify(window.appSettings));
                showNotification('💾 Settings saved successfully', 'success');
            } catch (error) {
                showNotification('❌ Failed to save settings', 'error');
                logError('Settings save failed', error);
            }
        }

        // ===== ANIMATION SYSTEM =====

        function addAnimation(element, animationClass, duration = 300) {
            if (!element) {
                window.logger?.warn('Animation target element not found', { animationClass }, 'ANIMATION');
                return;
            }

            try {
                element.classList.add(animationClass);
                const timeoutId = setTimeout(() => {
                    if (element && element.classList) {
                        element.classList.remove(animationClass);
                    }
                }, duration);

                // Store timeout ID for potential cleanup
                if (!element._animationTimeouts) element._animationTimeouts = [];
                element._animationTimeouts.push(timeoutId);

                // Clean up old timeouts
                if (element._animationTimeouts.length > 10) {
                    const oldTimeout = element._animationTimeouts.shift();
                    clearTimeout(oldTimeout);
                }
            } catch (error) {
                window.logger?.error('Animation failed', { error: error.message, animationClass }, 'ANIMATION');
            }
        }

        function animateElement(selector, animation) {
            const element = document.querySelector(selector);
            if (element) {
                addAnimation(element, animation);
            }
        }

        // ===== ERROR HANDLING & CRASH REPORTING =====

        function showError(title, message, error = null) {
            const dialog = document.getElementById('error-dialog');
            const messageEl = document.getElementById('error-message');

            let fullMessage = message;
            if (error) {
                fullMessage += '\n\nTechnical Details:\n' + error.stack || error.message || error;
            }

            messageEl.textContent = fullMessage;
            dialog.style.display = 'block';
            addAnimation(dialog, 'bounce-in');

            // Log error
            logError(title, error || message);
        }

        function closeErrorDialog() {
            document.getElementById('error-dialog').style.display = 'none';
        }

        function reportError() {
            const errorMsg = document.getElementById('error-message').textContent;
            const reportData = {
                error: errorMsg,
                userAgent: navigator.userAgent,
                timestamp: new Date().toISOString(),
                settings: window.appSettings,
                url: window.location.href
            };

            // In a real app, this would send to an error reporting service
            console.log('Error Report:', reportData);
            showNotification('🐛 Error report generated (check console)', 'info');

            // Copy to clipboard
            navigator.clipboard.writeText(JSON.stringify(reportData, null, 2)).then(() => {
                showNotification('📋 Error report copied to clipboard', 'success');
            });
        }

        function restartApp() {
            showLoading('Restarting application...');
            setTimeout(() => {
                window.location.reload();
            }, 1000);
        }

        // ===== DEVELOPER CONSOLE =====

        function toggleConsole() {
            const console = document.getElementById('dev-console');
            const isVisible = console.style.display === 'flex';
            console.style.display = isVisible ? 'none' : 'flex';

            if (!isVisible) {
                document.getElementById('console-input').focus();
                addAnimation(console, 'slide-in-left');
            }
        }

        function clearConsole() {
            document.getElementById('console-output').textContent = 'Console cleared.\n';
        }

        function logToConsole(message, type = 'info') {
            const output = document.getElementById('console-output');
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '[ERROR]' : type === 'warning' ? '[WARN]' : '[INFO]';
            output.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }

        function handleConsoleInput(event) {
            if (event.key === 'Enter') {
                const input = event.target;
                const command = input.value.trim();

                if (command) {
                    logToConsole(`> ${command}`, 'info');
                    executeConsoleCommand(command);
                    input.value = '';
                }
            }
        }

        function executeConsoleCommand(command) {
            const parts = command.toLowerCase().split(' ');
            const cmd = parts[0];
            const args = parts.slice(1);

            switch (cmd) {
                case 'help':
                    logToConsole('Available commands:', 'info');
                    logToConsole('  help - Show this help', 'info');
                    logToConsole('  clear - Clear console', 'info');
                    logToConsole('  reset - Reset sandbox', 'info');
                    logToConsole('  fps [limit] - Set FPS limit', 'info');
                    logToConsole('  debug [on/off] - Toggle debug mode', 'info');
                    logToConsole('  spawn [vehicle] - Spawn vehicle', 'info');
                    logToConsole('  settings - Show current settings', 'info');
                    logToConsole('  performance - Show performance stats', 'info');
                    logToConsole('  audit - Run comprehensive system audit', 'info');
                    logToConsole('  version - Show version information', 'info');
                    break;

                case 'clear':
                    clearConsole();
                    break;

                case 'reset':
                    resetSandbox();
                    logToConsole('Sandbox reset', 'info');
                    break;

                case 'fps':
                    if (args[0]) {
                        const fps = parseInt(args[0]);
                        if (fps >= 30 && fps <= 120) {
                            updateFPSLimit(fps);
                            logToConsole(`FPS limit set to ${fps}`, 'info');
                        } else {
                            logToConsole('FPS must be between 30 and 120', 'error');
                        }
                    } else {
                        logToConsole(`Current FPS limit: ${window.appSettings.graphics.fpsLimit}`, 'info');
                    }
                    break;

                case 'debug':
                    if (args[0] === 'on') {
                        toggleDebugMode(true);
                        logToConsole('Debug mode enabled', 'info');
                    } else if (args[0] === 'off') {
                        toggleDebugMode(false);
                        logToConsole('Debug mode disabled', 'info');
                    } else {
                        logToConsole(`Debug mode: ${window.appSettings.advanced.debugMode ? 'on' : 'off'}`, 'info');
                    }
                    break;

                case 'spawn':
                    if (args[0]) {
                        logToConsole(`Spawning vehicle: ${args[0]}`, 'info');
                        // Vehicle spawning logic would go here
                    } else {
                        logToConsole('Usage: spawn [excavator|bulldozer|dumptruck|crane|compactor]', 'error');
                    }
                    break;

                case 'settings':
                    logToConsole('Current settings:', 'info');
                    logToConsole(JSON.stringify(window.appSettings, null, 2), 'info');
                    break;

                case 'performance':
                    const stats = {
                        fps: document.getElementById('fps-counter')?.textContent || 'N/A',
                        vehicles: document.getElementById('vehicle-count')?.textContent || 'N/A',
                        terrain: document.getElementById('terrain-points')?.textContent || 'N/A',
                        memory: performance.memory ? `${Math.round(performance.memory.usedJSHeapSize / 1024 / 1024)}MB` : 'N/A'
                    };
                    logToConsole('Performance stats:', 'info');
                    logToConsole(JSON.stringify(stats, null, 2), 'info');
                    break;

                case 'audit':
                    logToConsole('Running comprehensive system audit...', 'info');
                    runAudit().then(report => {
                        logToConsole(`Audit completed: ${report.summary.successRate}% success rate`, 'info');
                        logToConsole(`${report.summary.passed}/${report.summary.totalTests} tests passed`, 'info');
                    }).catch(error => {
                        logToConsole(`Audit failed: ${error.message}`, 'error');
                    });
                    break;

                case 'version':
                    logToConsole('RC Sandbox v5.0 - Professional AR Construction Simulator', 'info');
                    logToConsole('Features: 30+ libraries, Modern UI, Comprehensive logging', 'info');
                    break;

                default:
                    logToConsole(`Unknown command: ${cmd}. Type 'help' for available commands.`, 'error');
            }
        }

        // ===== UTILITY FUNCTIONS =====

        function showLoading(message = 'Loading...') {
            const spinner = document.getElementById('loading-spinner');
            spinner.style.display = 'block';
            addAnimation(spinner, 'fade-in');
        }

        function hideLoading() {
            document.getElementById('loading-spinner').style.display = 'none';
        }

        function logError(title, error) {
            const errorData = {
                title: title,
                message: error?.message || error,
                stack: error?.stack,
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent
            };

            console.error('RC Sandbox Error:', errorData);
            logToConsole(`ERROR: ${title} - ${error?.message || error}`, 'error');

            // Store error for reporting
            if (!window.errorLog) window.errorLog = [];
            window.errorLog.push(errorData);
        }

        function applyGraphicsSettings() {
            const settings = window.appSettings.graphics;

            // Apply render quality
            if (renderer3d) {
                switch (settings.renderQuality) {
                    case 'low':
                        renderer3d.setPixelRatio(0.5);
                        break;
                    case 'medium':
                        renderer3d.setPixelRatio(0.75);
                        break;
                    case 'high':
                        renderer3d.setPixelRatio(1.0);
                        break;
                    case 'ultra':
                        renderer3d.setPixelRatio(window.devicePixelRatio);
                        break;
                }

                renderer3d.shadowMap.enabled = settings.shadows;
            }
        }

        function applyAudioSettings() {
            const settings = window.appSettings.audio;

            // Apply audio settings to Tone.js if available
            if (typeof Tone !== 'undefined') {
                Tone.Master.volume.value = (settings.masterVolume / 100) * -20; // Convert to dB
            }
        }

        function applyPerformanceProfile(profile) {
            switch (profile) {
                case 'battery':
                    updateFPSLimit(30);
                    updateRenderQuality('low');
                    toggleShadows(false);
                    toggleParticles(false);
                    break;
                case 'balanced':
                    updateFPSLimit(60);
                    updateRenderQuality('medium');
                    toggleShadows(true);
                    toggleParticles(true);
                    break;
                case 'performance':
                    updateFPSLimit(120);
                    updateRenderQuality('ultra');
                    toggleShadows(true);
                    toggleParticles(true);
                    break;
            }
        }

        function initializeDefaultSettings() {
            window.appSettings = {
                graphics: {
                    renderQuality: 'medium',
                    fpsLimit: 60,
                    shadows: true,
                    particles: true
                },
                audio: {
                    masterVolume: 70,
                    sfxVolume: 80,
                    musicVolume: 50,
                    terrainAudio: true
                },
                controls: {
                    mouseSensitivity: 1.0,
                    invertMouse: false,
                    gestures: true
                },
                advanced: {
                    debugMode: false,
                    telemetry: true,
                    autoSave: true,
                    performanceProfile: 'balanced'
                }
            };
        }

        function loadSettingsIntoUI() {
            const settings = window.appSettings;

            // Graphics
            document.getElementById('render-quality').value = settings.graphics.renderQuality;
            document.getElementById('fps-limit').value = settings.graphics.fpsLimit;
            document.getElementById('fps-limit-value').textContent = settings.graphics.fpsLimit + ' FPS';
            document.getElementById('enable-shadows').checked = settings.graphics.shadows;
            document.getElementById('enable-particles').checked = settings.graphics.particles;

            // Audio
            document.getElementById('master-volume').value = settings.audio.masterVolume;
            document.getElementById('master-volume-value').textContent = settings.audio.masterVolume + '%';
            document.getElementById('sfx-volume').value = settings.audio.sfxVolume;
            document.getElementById('sfx-volume-value').textContent = settings.audio.sfxVolume + '%';
            document.getElementById('music-volume').value = settings.audio.musicVolume;
            document.getElementById('music-volume-value').textContent = settings.audio.musicVolume + '%';
            document.getElementById('enable-terrain-audio').checked = settings.audio.terrainAudio;

            // Controls
            document.getElementById('mouse-sensitivity').value = settings.controls.mouseSensitivity;
            document.getElementById('mouse-sensitivity-value').textContent = settings.controls.mouseSensitivity + 'x';
            document.getElementById('invert-mouse').checked = settings.controls.invertMouse;
            document.getElementById('enable-gestures').checked = settings.controls.gestures;

            // Advanced
            document.getElementById('enable-debug').checked = settings.advanced.debugMode;
            document.getElementById('enable-telemetry').checked = settings.advanced.telemetry;
            document.getElementById('auto-save').checked = settings.advanced.autoSave;
            document.getElementById('performance-profile').value = settings.advanced.performanceProfile;
        }

        // ===== COMPREHENSIVE LOGGING SYSTEM =====

        class Logger {
            constructor() {
                this.logs = [];
                this.maxLogs = 1000;
                this.sessionStart = Date.now();
                this.counters = {
                    debug: 0,
                    info: 0,
                    warn: 0,
                    error: 0,
                    critical: 0
                };
                this.filters = {
                    debug: true,
                    info: true,
                    warn: true,
                    error: true,
                    critical: true
                };
            }

            log(level, message, data = null, source = 'SYSTEM') {
                const timestamp = new Date();
                const sessionTime = timestamp.getTime() - this.sessionStart;

                const logEntry = {
                    id: this.logs.length + 1,
                    timestamp: timestamp.toISOString(),
                    sessionTime: sessionTime,
                    level: level.toLowerCase(),
                    message: message,
                    data: data,
                    source: source,
                    stack: level === 'error' || level === 'critical' ? new Error().stack : null,
                    userAgent: navigator.userAgent,
                    url: window.location.href,
                    memory: performance.memory ? {
                        used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                        total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                        limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                    } : null
                };

                this.logs.push(logEntry);
                this.counters[level.toLowerCase()]++;

                // Maintain max logs limit
                if (this.logs.length > this.maxLogs) {
                    this.logs.shift();
                }

                // Update UI
                this.updateLogViewer();
                this.updateTelemetry();

                // Console output with styling
                const style = this.getConsoleStyle(level);
                console.log(`%c[${timestamp.toLocaleTimeString()}] [${level.toUpperCase()}] [${source}] ${message}`, style, data || '');

                // Send to external logging service (if configured)
                this.sendToExternalService(logEntry);

                return logEntry;
            }

            debug(message, data = null, source = 'DEBUG') {
                return this.log('debug', message, data, source);
            }

            info(message, data = null, source = 'INFO') {
                return this.log('info', message, data, source);
            }

            warn(message, data = null, source = 'WARN') {
                return this.log('warn', message, data, source);
            }

            error(message, data = null, source = 'ERROR') {
                return this.log('error', message, data, source);
            }

            critical(message, data = null, source = 'CRITICAL') {
                return this.log('critical', message, data, source);
            }

            getConsoleStyle(level) {
                const styles = {
                    debug: 'color: #888; font-size: 11px;',
                    info: 'color: #00aa00; font-weight: normal;',
                    warn: 'color: #ff8800; font-weight: bold;',
                    error: 'color: #ff4444; font-weight: bold;',
                    critical: 'color: #ff0000; font-weight: bold; background: #ffeeee;'
                };
                return styles[level.toLowerCase()] || styles.info;
            }

            updateLogViewer() {
                const logContent = document.getElementById('log-content');
                if (!logContent) return;

                const filteredLogs = this.logs.filter(log => this.filters[log.level]);
                const logText = filteredLogs.slice(-100).map(log => {
                    const time = new Date(log.timestamp).toLocaleTimeString();
                    const sessionTime = Math.round(log.sessionTime / 1000);
                    return `[${time}] [+${sessionTime}s] [${log.level.toUpperCase()}] [${log.source}] ${log.message}${log.data ? '\n  Data: ' + JSON.stringify(log.data) : ''}`;
                }).join('\n');

                logContent.textContent = logText;
                logContent.scrollTop = logContent.scrollHeight;
            }

            updateTelemetry() {
                const sessionTime = Math.floor((Date.now() - this.sessionStart) / 1000);
                const hours = Math.floor(sessionTime / 3600);
                const minutes = Math.floor((sessionTime % 3600) / 60);
                const seconds = sessionTime % 60;

                const elements = {
                    'session-time': `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`,
                    'telemetry-errors': this.counters.error + this.counters.critical,
                    'telemetry-warnings': this.counters.warn,
                    'telemetry-events': this.logs.length
                };

                Object.entries(elements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) element.textContent = value;
                });

                // Update memory if available
                if (performance.memory) {
                    const memoryElement = document.getElementById('telemetry-memory');
                    if (memoryElement) {
                        memoryElement.textContent = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB';
                    }
                }
            }

            sendToExternalService(logEntry) {
                // In a production environment, this would send logs to a service like:
                // - Sentry, LogRocket, Bugsnag
                // - Custom logging endpoint
                // - Analytics service

                if (window.appSettings?.advanced?.telemetry && logEntry.level !== 'debug') {
                    // Simulate sending to external service
                    if (window.externalLoggingEnabled) {
                        console.log('📡 Sending to external logging service:', logEntry);
                        // fetch('/api/logs', { method: 'POST', body: JSON.stringify(logEntry) });
                    }
                }
            }

            exportLogs() {
                const exportData = {
                    sessionInfo: {
                        startTime: new Date(this.sessionStart).toISOString(),
                        duration: Date.now() - this.sessionStart,
                        userAgent: navigator.userAgent,
                        url: window.location.href,
                        settings: window.appSettings
                    },
                    counters: this.counters,
                    logs: this.logs,
                    systemInfo: {
                        memory: performance.memory ? {
                            used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                            total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                            limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                        } : null,
                        connection: navigator.connection ? {
                            effectiveType: navigator.connection.effectiveType,
                            downlink: navigator.connection.downlink,
                            rtt: navigator.connection.rtt
                        } : null,
                        platform: navigator.platform,
                        language: navigator.language,
                        cookieEnabled: navigator.cookieEnabled,
                        onLine: navigator.onLine
                    }
                };

                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `rc-sandbox-logs-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.info('Logs exported successfully', { filename: a.download }, 'EXPORT');
                showNotification('📋 Logs exported to file', 'success');
            }

            clearLogs() {
                this.logs = [];
                this.counters = { debug: 0, info: 0, warn: 0, error: 0, critical: 0 };
                this.updateLogViewer();
                this.updateTelemetry();
                this.info('Logs cleared', null, 'SYSTEM');
            }

            getStats() {
                return {
                    totalLogs: this.logs.length,
                    counters: { ...this.counters },
                    sessionDuration: Date.now() - this.sessionStart,
                    memoryUsage: performance.memory ? Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) : null
                };
            }
        }

        // Initialize global logger
        window.logger = new Logger();

        // ===== ERROR REPORTING SYSTEM =====

        class ErrorReporter {
            constructor(logger) {
                this.logger = logger;
                this.errorQueue = [];
                this.reportingEnabled = true;
                this.maxQueueSize = 50;
            }

            reportError(error, context = {}) {
                const errorReport = {
                    id: Date.now() + Math.random(),
                    timestamp: new Date().toISOString(),
                    error: {
                        name: error.name || 'Unknown Error',
                        message: error.message || 'No message',
                        stack: error.stack || 'No stack trace',
                        fileName: error.fileName || 'Unknown file',
                        lineNumber: error.lineNumber || 0,
                        columnNumber: error.columnNumber || 0
                    },
                    context: {
                        ...context,
                        url: window.location.href,
                        userAgent: navigator.userAgent,
                        timestamp: Date.now(),
                        sessionDuration: Date.now() - window.logger.sessionStart,
                        settings: window.appSettings,
                        lastActions: this.getLastUserActions(),
                        systemState: this.getSystemState()
                    },
                    severity: this.calculateSeverity(error),
                    fingerprint: this.generateFingerprint(error)
                };

                this.errorQueue.push(errorReport);

                // Maintain queue size
                if (this.errorQueue.length > this.maxQueueSize) {
                    this.errorQueue.shift();
                }

                this.logger.error('Error reported', errorReport, 'ERROR_REPORTER');

                // Send to external service
                this.sendErrorReport(errorReport);

                return errorReport;
            }

            calculateSeverity(error) {
                const message = error.message?.toLowerCase() || '';
                const stack = error.stack?.toLowerCase() || '';

                if (message.includes('network') || message.includes('fetch')) return 'low';
                if (message.includes('permission') || message.includes('security')) return 'medium';
                if (message.includes('memory') || message.includes('quota')) return 'high';
                if (stack.includes('three.js') || stack.includes('webgl')) return 'medium';
                if (stack.includes('physics') || stack.includes('cannon')) return 'medium';

                return 'medium';
            }

            generateFingerprint(error) {
                const key = `${error.name}-${error.message}-${error.fileName}-${error.lineNumber}`;
                return btoa(key).slice(0, 16);
            }

            getLastUserActions() {
                // In a real app, this would track user interactions
                return window.userActionHistory || [];
            }

            getSystemState() {
                return {
                    fps: document.getElementById('fps-counter')?.textContent || 'unknown',
                    vehicles: document.getElementById('vehicle-count')?.textContent || 'unknown',
                    terrainPoints: document.getElementById('terrain-points')?.textContent || 'unknown',
                    memory: performance.memory ? Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB' : 'unknown',
                    online: navigator.onLine,
                    visibility: document.visibilityState
                };
            }

            sendErrorReport(report) {
                if (!this.reportingEnabled) return;

                // In production, send to error reporting service
                console.log('🚨 Error Report Generated:', report);

                // Simulate sending to external service
                if (window.appSettings?.advanced?.telemetry) {
                    // fetch('/api/errors', { method: 'POST', body: JSON.stringify(report) });
                }
            }

            getErrorStats() {
                const severityCounts = this.errorQueue.reduce((acc, error) => {
                    acc[error.severity] = (acc[error.severity] || 0) + 1;
                    return acc;
                }, {});

                return {
                    totalErrors: this.errorQueue.length,
                    severityCounts,
                    uniqueErrors: new Set(this.errorQueue.map(e => e.fingerprint)).size,
                    lastError: this.errorQueue[this.errorQueue.length - 1]
                };
            }
        }

        // Initialize global error reporter
        window.errorReporter = new ErrorReporter(window.logger);

        // ===== INITIALIZATION =====

        // Initialize settings
        try {
            const savedSettings = localStorage.getItem('rc-sandbox-settings');
            if (savedSettings) {
                window.appSettings = JSON.parse(savedSettings);
            } else {
                initializeDefaultSettings();
            }
        } catch (error) {
            logError('Settings load failed', error);
            initializeDefaultSettings();
        }

        // Load settings into UI
        loadSettingsIntoUI();

        // Apply initial settings
        applyGraphicsSettings();
        applyAudioSettings();

        // Enhanced global error handlers
        window.addEventListener('error', (event) => {
            const error = event.error || new Error(event.message);
            window.logger.critical('Uncaught JavaScript Error', {
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                stack: error.stack
            }, 'GLOBAL_ERROR');

            window.errorReporter.reportError(error, {
                type: 'uncaught_error',
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });

            showError('JavaScript Error', event.message, error);
        });

        window.addEventListener('unhandledrejection', (event) => {
            const error = event.reason instanceof Error ? event.reason : new Error(event.reason);
            window.logger.critical('Unhandled Promise Rejection', {
                reason: event.reason,
                stack: error.stack
            }, 'PROMISE_ERROR');

            window.errorReporter.reportError(error, {
                type: 'unhandled_rejection',
                reason: event.reason
            });

            showError('Unhandled Promise Rejection', event.reason, error);
        });

        // Resource loading error handler
        window.addEventListener('error', (event) => {
            if (event.target !== window) {
                window.logger.error('Resource loading failed', {
                    tagName: event.target.tagName,
                    src: event.target.src || event.target.href,
                    type: event.target.type
                }, 'RESOURCE_ERROR');
            }
        }, true);

        // Network status monitoring
        window.addEventListener('online', () => {
            window.logger.info('Network connection restored', null, 'NETWORK');
            document.getElementById('telemetry-network').textContent = 'ONLINE';
        });

        window.addEventListener('offline', () => {
            window.logger.warn('Network connection lost', null, 'NETWORK');
            document.getElementById('telemetry-network').textContent = 'OFFLINE';
        });

        // Page visibility monitoring
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                window.logger.info('Page hidden', null, 'VISIBILITY');
            } else {
                window.logger.info('Page visible', null, 'VISIBILITY');
            }
        });

        // Memory pressure monitoring (if supported) - FIXED MEMORY LEAK
        if ('memory' in performance) {
            const memoryMonitorId = setInterval(() => {
                try {
                    const memory = performance.memory;
                    const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                    const limitMB = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);
                    const percentage = (usedMB / limitMB) * 100;

                    if (percentage > 80) {
                        window.logger.warn('High memory usage detected', {
                            used: usedMB,
                            limit: limitMB,
                            percentage: Math.round(percentage)
                        }, 'MEMORY_MONITOR');
                    }
                } catch (error) {
                    console.error('Memory monitoring error:', error);
                }
            }, 30000); // Check every 30 seconds

            // Store interval ID for cleanup
            if (!window.intervalIds) window.intervalIds = [];
            window.intervalIds.push(memoryMonitorId);
        }

        // ===== LOG VIEWER FUNCTIONS =====

        function toggleLogViewer() {
            const viewer = document.getElementById('log-viewer');
            const isVisible = viewer.style.display === 'flex';
            viewer.style.display = isVisible ? 'none' : 'flex';

            if (!isVisible) {
                addAnimation(viewer, 'slide-in-right');
                window.logger.info('Log viewer opened', null, 'UI');
            } else {
                window.logger.info('Log viewer closed', null, 'UI');
            }
        }

        function exportLogs() {
            window.logger.exportLogs();
        }

        function clearLogs() {
            if (confirm('Clear all logs? This cannot be undone.')) {
                window.logger.clearLogs();
                showNotification('🗑️ Logs cleared', 'info');
            }
        }

        function updateLogFilter() {
            const filters = ['debug', 'info', 'warn', 'error'];
            filters.forEach(level => {
                const checkbox = document.getElementById(`log-${level}`);
                if (checkbox) {
                    window.logger.filters[level] = checkbox.checked;
                }
            });
            window.logger.updateLogViewer();
        }

        function toggleTelemetry() {
            const panel = document.getElementById('telemetry-panel');
            const isVisible = panel.style.display === 'block';
            panel.style.display = isVisible ? 'none' : 'block';

            if (!isVisible) {
                addAnimation(panel, 'slide-in-right');
                window.logger.info('Telemetry panel opened', null, 'UI');
            }
        }

        // ===== ENHANCED ERROR HANDLING =====

        function logError(title, error) {
            // Use new logging system
            window.logger.error(title, {
                error: error?.message || error,
                stack: error?.stack,
                type: error?.constructor?.name
            }, 'ERROR_HANDLER');

            // Report to error reporting system
            if (error instanceof Error) {
                window.errorReporter.reportError(error, { title, source: 'manual' });
            }
        }

        function showError(title, message, error = null) {
            const dialog = document.getElementById('error-dialog');
            const messageEl = document.getElementById('error-message');

            let fullMessage = message;
            if (error) {
                fullMessage += '\n\nTechnical Details:\n' + (error.stack || error.message || error);

                // Report error
                if (error instanceof Error) {
                    window.errorReporter.reportError(error, { title, source: 'ui_error' });
                }
            }

            messageEl.textContent = fullMessage;
            dialog.style.display = 'block';
            addAnimation(dialog, 'bounce-in');

            // Log error
            window.logger.error(title, { message, error: error?.message }, 'UI_ERROR');
        }

        function reportError() {
            const errorMsg = document.getElementById('error-message').textContent;
            const stats = window.logger.getStats();
            const errorStats = window.errorReporter.getErrorStats();

            const reportData = {
                currentError: errorMsg,
                logStats: stats,
                errorStats: errorStats,
                systemInfo: {
                    userAgent: navigator.userAgent,
                    timestamp: new Date().toISOString(),
                    settings: window.appSettings,
                    url: window.location.href,
                    memory: performance.memory ? {
                        used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                        total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024)
                    } : null
                },
                recentLogs: window.logger.logs.slice(-20) // Last 20 log entries
            };

            // In a real app, this would send to an error reporting service
            console.log('🐛 Comprehensive Error Report:', reportData);
            window.logger.info('Error report generated', { reportSize: JSON.stringify(reportData).length }, 'ERROR_REPORT');

            // Copy to clipboard
            navigator.clipboard.writeText(JSON.stringify(reportData, null, 2)).then(() => {
                showNotification('📋 Comprehensive error report copied to clipboard', 'success');
            }).catch(() => {
                showNotification('❌ Failed to copy error report', 'error');
            });
        }

        // ===== PERFORMANCE MONITORING =====

        function startPerformanceMonitoring() {
            // Cache DOM elements for performance (PERFORMANCE OPTIMIZATION)
            const domCache = {
                fpsCounter: document.getElementById('fps-counter'),
                telemetryFps: document.getElementById('telemetry-fps')
            };

            const performanceMonitorId = setInterval(() => {
                try {
                    // Update telemetry safely
                    if (window.logger && window.logger.updateTelemetry) {
                        window.logger.updateTelemetry();
                    }

                    // Log performance metrics periodically
                    if (performance.memory) {
                        const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                        if (memoryMB > 100) { // Log if memory usage is high
                            if (window.logger && window.logger.warn) {
                                window.logger.warn(`High memory usage: ${memoryMB}MB`, {
                                    used: memoryMB,
                                    total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024)
                                }, 'PERFORMANCE');
                            }
                        }
                    }

                    // Check FPS with cached elements (PERFORMANCE + NULL SAFETY)
                    if (domCache.fpsCounter && domCache.telemetryFps) {
                        const fps = parseInt(domCache.fpsCounter.textContent) || 0;
                        domCache.telemetryFps.textContent = fps;

                        if (fps < 30 && fps > 0) {
                            if (window.logger && window.logger.warn) {
                                window.logger.warn(`Low FPS detected: ${fps}`, { fps }, 'PERFORMANCE');
                            }
                        }
                    }
                } catch (error) {
                    console.error('Performance monitoring error:', error);
                }
            }, 5000); // Every 5 seconds

            // Store interval ID for cleanup (CRITICAL MEMORY LEAK FIX)
            if (!window.intervalIds) window.intervalIds = [];
            window.intervalIds.push(performanceMonitorId);

            return performanceMonitorId;
        }

        // ===== USER ACTION TRACKING =====

        function trackUserAction(action, data = {}) {
            if (!window.userActionHistory) window.userActionHistory = [];

            const actionEntry = {
                timestamp: Date.now(),
                action: action,
                data: data,
                url: window.location.href
            };

            window.userActionHistory.push(actionEntry);

            // Keep only last 50 actions
            if (window.userActionHistory.length > 50) {
                window.userActionHistory.shift();
            }

            window.logger.debug(`User action: ${action}`, data, 'USER_ACTION');
        }

        // Track common user actions
        document.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON' || e.target.classList.contains('glass-button')) {
                trackUserAction('button_click', {
                    text: e.target.textContent?.trim(),
                    id: e.target.id,
                    className: e.target.className
                });
            }
        });

        // Enhanced keyboard shortcuts with logging
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            const modifiers = {
                ctrl: e.ctrlKey,
                meta: e.metaKey,
                shift: e.shiftKey,
                alt: e.altKey
            };

            trackUserAction('keydown', { key, modifiers });

            switch(key) {
                case 'h':
                    if (!e.ctrlKey && !e.metaKey) {
                        toggleHelp();
                        window.logger.info('Help toggled via keyboard', null, 'KEYBOARD');
                    }
                    break;
                case 'r':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        resetSandbox();
                        window.logger.info('Sandbox reset via keyboard', null, 'KEYBOARD');
                    }
                    break;
                case 'f':
                    if (!e.ctrlKey && !e.metaKey) {
                        if (!document.fullscreenElement) {
                            document.documentElement.requestFullscreen();
                            window.logger.info('Fullscreen enabled', null, 'KEYBOARD');
                        } else {
                            document.exitFullscreen();
                            window.logger.info('Fullscreen disabled', null, 'KEYBOARD');
                        }
                    }
                    break;
                case '`':
                case '~':
                    e.preventDefault();
                    toggleConsole();
                    break;
                case 'l':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        toggleLogViewer();
                    }
                    break;
                case 't':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        toggleTelemetry();
                    }
                    break;
                case 'escape':
                    closeSettings();
                    closeErrorDialog();
                    document.getElementById('log-viewer').style.display = 'none';
                    document.getElementById('telemetry-panel').style.display = 'none';
                    window.logger.debug('Escape pressed - closing dialogs', null, 'KEYBOARD');
                    break;
                case ' ':
                    e.preventDefault();
                    // Toggle pause (if implemented)
                    window.logger.debug('Space pressed - pause/resume', null, 'KEYBOARD');
                    break;
            }
        });

        // ===== LIBRARY COMPATIBILITY CHECK =====
        function checkLibraryCompatibility() {
            const requiredLibraries = [
                { name: 'THREE', check: () => typeof THREE !== 'undefined' },
                { name: 'Matter', check: () => typeof Matter !== 'undefined' },
                { name: 'Tone', check: () => typeof Tone !== 'undefined' }
            ];

            const missing = [];
            const loaded = [];

            requiredLibraries.forEach(lib => {
                try {
                    if (lib.check()) {
                        loaded.push(lib.name);
                    } else {
                        missing.push(lib.name);
                    }
                } catch (error) {
                    missing.push(lib.name);
                }
            });

            if (missing.length > 0) {
                console.warn('Missing libraries:', missing);
                showNotification(`⚠️ Some libraries failed to load: ${missing.join(', ')}`, 'warning', 8000);
            }

            return { loaded, missing };
        }

        // Initialize logging and monitoring systems
        window.logger.info('RC Sandbox application starting', {
            version: '5.0.0',
            userAgent: navigator.userAgent,
            timestamp: new Date().toISOString()
        }, 'STARTUP');

        // Check library compatibility
        const libraryStatus = checkLibraryCompatibility();
        window.logger.info('Library compatibility check', libraryStatus, 'STARTUP');

        // Start performance monitoring
        startPerformanceMonitoring();

        // Show telemetry panel if debug mode is enabled
        if (window.appSettings?.advanced?.debugMode) {
            document.getElementById('telemetry-panel').style.display = 'block';
        }

        // Initialize Gamification System - PUZZLE PIECE INTEGRATION
        initializeGamificationSystem();

        // Log initial system state
        window.logger.info('System initialization complete', {
            settings: window.appSettings,
            memory: performance.memory ? Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB' : 'unknown',
            online: navigator.onLine,
            libraries: '30+ integrated'
        }, 'INIT');

        // Show welcome notification with enhanced shortcuts
        setTimeout(() => {
            showNotification('🏗️ Welcome to RC Sandbox! H=help, `=console, Ctrl+L=logs, Ctrl+T=telemetry', 'info', 6000);
            window.logger.info('Welcome notification shown', null, 'UI');
        }, 1000);

        // Log successful startup
        window.logger.info('RC Sandbox fully loaded and ready', {
            loadTime: Date.now() - window.logger.sessionStart,
            features: ['30+ libraries', 'Modern UI', 'Comprehensive logging', 'Error reporting', 'Performance monitoring']
        }, 'READY');

        // Initialize voxel controls
        setupVoxelControls();

        // Initialize museum experience
        setupMuseumExperience();

        // Make terrain globally accessible
        window.terrain = terrain;

        // NEW FEATURES (2025-06-29) - GAMIFICATION UPDATE
        console.log('🎉 RC Sandbox Professional - Updated 2025-06-29');
        console.log('✨ New Features:');
        console.log('  • Enhanced performance monitoring');
        console.log('  • Improved terrain physics');
        console.log('  • Better mobile compatibility');
        console.log('  • Advanced particle effects');
        console.log('  • 🎮 GAMIFICATION SYSTEM - Levels, XP, Achievements!');
        console.log('  • 🏆 Daily Challenges & Rewards');
        console.log('  • ⚡ Energy System & Power-ups');
        console.log('  • 🎊 Professional UI with Animations');

        // Performance monitoring
        let frameCount = 0;
        let lastTime = performance.now();

        function updatePerformanceStats() {
            frameCount++;
            const currentTime = performance.now();

            if (currentTime - lastTime >= 1000) {
                const fps = Math.round(frameCount * 1000 / (currentTime - lastTime));
                const memoryUsage = performance.memory ?
                    Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) : 'N/A';

                // Update performance display if element exists
                const perfDisplay = document.getElementById('performance-stats');
                if (perfDisplay) {
                    perfDisplay.textContent = `FPS: ${fps} | Memory: ${memoryUsage}MB`;
                }

                frameCount = 0;
                lastTime = currentTime;
            }

            requestAnimationFrame(updatePerformanceStats);
        }

        // Start performance monitoring
        updatePerformanceStats();

        // Add keyboard shortcuts info
        console.log('⌨️  Keyboard Shortcuts:');
        console.log('  • Space: Toggle physics simulation');
        console.log('  • W: Add water at center');
        console.log('  • R: Reset terrain');
        console.log('  • F: Toggle fullscreen');
        console.log('  • H: Show/hide help');

        // ===== COMPREHENSIVE TESTING & AUDIT SYSTEM =====

        class SystemAuditor {
            constructor() {
                this.testResults = [];
                this.version = '5.0';
                this.auditStartTime = Date.now();
            }

            async runComprehensiveAudit() {
                window.logger.info('Starting comprehensive system audit v5.0', null, 'AUDIT');

                const tests = [
                    { name: 'DOM Elements', test: () => this.testDOMElements() },
                    { name: 'External Libraries', test: () => this.testExternalLibraries() },
                    { name: 'Event Listeners', test: () => this.testEventListeners() },
                    { name: 'Memory Management', test: () => this.testMemoryManagement() },
                    { name: 'Error Handling', test: () => this.testErrorHandling() },
                    { name: 'Performance', test: () => this.testPerformance() },
                    { name: 'UI Components', test: () => this.testUIComponents() },
                    { name: 'Logging System', test: () => this.testLoggingSystem() },
                    { name: 'Settings System', test: () => this.testSettingsSystem() },
                    { name: 'Keyboard Shortcuts', test: () => this.testKeyboardShortcuts() }
                ];

                for (const testCase of tests) {
                    try {
                        const result = await testCase.test();
                        this.testResults.push({
                            name: testCase.name,
                            status: 'PASS',
                            result: result,
                            timestamp: Date.now()
                        });
                        window.logger.info(`✅ ${testCase.name} test passed`, result, 'AUDIT');
                    } catch (error) {
                        this.testResults.push({
                            name: testCase.name,
                            status: 'FAIL',
                            error: error.message,
                            timestamp: Date.now()
                        });
                        window.logger.error(`❌ ${testCase.name} test failed`, { error: error.message }, 'AUDIT');
                    }
                }

                return this.generateAuditReport();
            }

            testDOMElements() {
                const requiredElements = [
                    'canvas', 'canvas3d', 'video', 'settings-overlay', 'dev-console',
                    'log-viewer', 'telemetry-panel', 'error-dialog', 'help-overlay',
                    'notification-container', 'fps-counter', 'vehicle-count', 'terrain-points'
                ];

                const missing = [];
                const found = [];

                requiredElements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        found.push(id);
                    } else {
                        missing.push(id);
                    }
                });

                if (missing.length > 0) {
                    throw new Error(`Missing DOM elements: ${missing.join(', ')}`);
                }

                return { found: found.length, total: requiredElements.length };
            }

            testExternalLibraries() {
                const libraries = [
                    { name: 'THREE', check: () => typeof THREE !== 'undefined' },
                    { name: 'Tone', check: () => typeof Tone !== 'undefined' },
                    { name: 'Matter', check: () => typeof Matter !== 'undefined' },
                    { name: 'p5', check: () => typeof p5 !== 'undefined' },
                    { name: 'Logger', check: () => window.logger instanceof Logger },
                    { name: 'ErrorReporter', check: () => window.errorReporter instanceof ErrorReporter }
                ];

                const results = {};
                libraries.forEach(lib => {
                    try {
                        results[lib.name] = lib.check();
                    } catch (error) {
                        results[lib.name] = false;
                    }
                });

                const failed = Object.entries(results).filter(([name, status]) => !status);
                if (failed.length > 0) {
                    throw new Error(`Failed library checks: ${failed.map(([name]) => name).join(', ')}`);
                }

                return results;
            }

            testEventListeners() {
                const events = [];

                // Test keyboard events
                const testKeyEvent = new KeyboardEvent('keydown', { key: 'h' });
                document.dispatchEvent(testKeyEvent);
                events.push('keyboard');

                // Test click events
                const testButton = document.querySelector('.glass-button');
                if (testButton) {
                    const testClickEvent = new MouseEvent('click', { bubbles: true });
                    testButton.dispatchEvent(testClickEvent);
                    events.push('click');
                }

                return { eventsWorking: events };
            }

            testMemoryManagement() {
                const initialMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;

                // Create and destroy some objects to test GC
                const testObjects = [];
                for (let i = 0; i < 1000; i++) {
                    testObjects.push({ data: new Array(100).fill(i) });
                }
                testObjects.length = 0; // Clear array

                const afterMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;

                return {
                    initialMemory: Math.round(initialMemory / 1024 / 1024),
                    afterMemory: Math.round(afterMemory / 1024 / 1024),
                    memoryAvailable: !!performance.memory
                };
            }

            testErrorHandling() {
                const originalErrorCount = window.logger.counters.error;

                try {
                    // Trigger a controlled error
                    throw new Error('Test error for audit');
                } catch (error) {
                    window.errorReporter.reportError(error, { source: 'audit_test' });
                }

                const newErrorCount = window.logger.counters.error;

                if (newErrorCount <= originalErrorCount) {
                    throw new Error('Error handling system not working');
                }

                return { errorsCaptured: newErrorCount - originalErrorCount };
            }

            testPerformance() {
                const start = performance.now();

                // Simulate some work
                for (let i = 0; i < 10000; i++) {
                    Math.random() * Math.random();
                }

                const end = performance.now();
                const duration = end - start;

                if (duration > 100) {
                    throw new Error(`Performance test too slow: ${duration}ms`);
                }

                return { duration: Math.round(duration * 100) / 100 };
            }

            testUIComponents() {
                const components = [
                    'settings-overlay', 'dev-console', 'log-viewer',
                    'telemetry-panel', 'error-dialog', 'help-overlay'
                ];

                const results = {};
                components.forEach(id => {
                    const element = document.getElementById(id);
                    results[id] = {
                        exists: !!element,
                        visible: element ? element.style.display !== 'none' : false,
                        hasClasses: element ? element.classList.length > 0 : false
                    };
                });

                return results;
            }

            testLoggingSystem() {
                const initialLogCount = window.logger.logs.length;

                window.logger.debug('Audit test debug message');
                window.logger.info('Audit test info message');
                window.logger.warn('Audit test warning message');

                const newLogCount = window.logger.logs.length;

                if (newLogCount !== initialLogCount + 3) {
                    throw new Error('Logging system not capturing all messages');
                }

                return {
                    logsAdded: newLogCount - initialLogCount,
                    totalLogs: newLogCount,
                    counters: window.logger.counters
                };
            }

            testSettingsSystem() {
                const originalSettings = JSON.stringify(window.appSettings);

                // Test setting modification
                const originalFPS = window.appSettings.graphics.fpsLimit;
                window.appSettings.graphics.fpsLimit = 45;

                if (window.appSettings.graphics.fpsLimit !== 45) {
                    throw new Error('Settings modification failed');
                }

                // Restore original
                window.appSettings.graphics.fpsLimit = originalFPS;

                return { settingsModifiable: true };
            }

            testKeyboardShortcuts() {
                const shortcuts = [
                    { key: 'h', description: 'Help toggle' },
                    { key: '`', description: 'Console toggle' },
                    { key: 'Escape', description: 'Close dialogs' }
                ];

                // Test that keyboard handler exists
                const hasKeyboardHandler = document._keyboardHandlerAttached || true;

                return {
                    shortcutsConfigured: shortcuts.length,
                    handlerAttached: hasKeyboardHandler
                };
            }

            generateAuditReport() {
                const passedTests = this.testResults.filter(t => t.status === 'PASS').length;
                const totalTests = this.testResults.length;
                const successRate = Math.round((passedTests / totalTests) * 100);
                const auditDuration = Date.now() - this.auditStartTime;

                const report = {
                    version: this.version,
                    timestamp: new Date().toISOString(),
                    auditDuration: auditDuration,
                    summary: {
                        totalTests: totalTests,
                        passed: passedTests,
                        failed: totalTests - passedTests,
                        successRate: successRate
                    },
                    testResults: this.testResults,
                    systemInfo: {
                        userAgent: navigator.userAgent,
                        memory: performance.memory ? {
                            used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                            total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024)
                        } : null,
                        online: navigator.onLine,
                        cookieEnabled: navigator.cookieEnabled,
                        language: navigator.language
                    },
                    recommendations: this.generateRecommendations()
                };

                window.logger.info('System audit completed', {
                    successRate: successRate,
                    duration: auditDuration,
                    version: this.version
                }, 'AUDIT');

                return report;
            }

            generateRecommendations() {
                const recommendations = [];
                const failedTests = this.testResults.filter(t => t.status === 'FAIL');

                if (failedTests.length === 0) {
                    recommendations.push('✅ All systems operational - ready for production deployment');
                } else {
                    recommendations.push('⚠️ Some tests failed - review and fix before deployment');
                    failedTests.forEach(test => {
                        recommendations.push(`🔧 Fix ${test.name}: ${test.error}`);
                    });
                }

                if (performance.memory) {
                    const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                    if (memoryMB > 100) {
                        recommendations.push(`💾 High memory usage detected: ${memoryMB}MB - consider optimization`);
                    }
                }

                return recommendations;
            }
        }

        // Initialize global auditor
        window.systemAuditor = new SystemAuditor();

        // Add audit command to console
        function runAudit() {
            return window.systemAuditor.runComprehensiveAudit().then(report => {
                console.log('🔍 RC Sandbox v5.0 Audit Report:', report);
                window.logger.info('Audit report generated', { successRate: report.summary.successRate }, 'AUDIT');
                return report;
            });
        }

        // ===== PROFESSIONAL CARTOGRAPHIC INTERFACE =====

        let currentTool = 'excavate';
        let visualizationMode = 'topographic';

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.professional-button').forEach(btn => {
                btn.style.background = '#2c3e50';
            });
            event.target.style.background = '#3498db';

            // Update cursor based on tool
            const canvas = document.getElementById('canvas');
            switch(tool) {
                case 'excavate':
                    canvas.style.cursor = 'crosshair';
                    break;
                case 'build':
                    canvas.style.cursor = 'copy';
                    break;
                case 'grade':
                    canvas.style.cursor = 'move';
                    break;
                case 'measure':
                    canvas.style.cursor = 'help';
                    break;
            }

            window.logger?.info('Tool changed', { tool }, 'INTERFACE');
        }

        function updateVisualizationMode() {
            const select = document.getElementById('visualization-mode');
            visualizationMode = select.value;

            // Update terrain rendering based on mode
            if (window.terrain) {
                switch(visualizationMode) {
                    case 'topographic':
                        window.terrain.setRenderMode('topographic');
                        break;
                    case 'contour':
                        window.terrain.setRenderMode('contour');
                        break;
                    case 'elevation':
                        window.terrain.setRenderMode('heatmap');
                        break;
                    case 'slope':
                        window.terrain.setRenderMode('slope');
                        break;
                    case 'watershed':
                        window.terrain.setRenderMode('watershed');
                        break;
                }
            }

            window.logger?.info('Visualization mode changed', { mode: visualizationMode }, 'INTERFACE');
        }

        function updateElevationDisplay(x, y) {
            if (!window.terrain) return;

            const elevation = window.terrain.getElevationAt(x, y) || 0;
            const slope = window.terrain.getSlopeAt(x, y) || 0;

            document.getElementById('current-elevation').textContent = elevation.toFixed(1) + 'm';
            document.getElementById('current-slope').textContent = slope.toFixed(1) + '°';
        }

        function resetTerrain() {
            if (window.terrain) {
                window.terrain.reset();
                window.logger?.info('Terrain reset', null, 'INTERFACE');
            }
        }

        // Initialize visualization mode selector
        document.addEventListener('DOMContentLoaded', () => {
            const select = document.getElementById('visualization-mode');
            if (select) {
                select.addEventListener('change', updateVisualizationMode);
            }

            // Set default tool
            setTool('excavate');
        });

        // Note: All keyboard events are handled by the comprehensive keyboard handler above

        // ===== GAMIFICATION SYSTEM - PUZZLE PIECE INTEGRATION =====
        function initializeGamificationSystem() {
            window.gameState = {
                level: 12,
                xp: 2340,
                xpToNext: 3500,
                energy: 85,
                maxEnergy: 100,
                achievements: new Set(),
                dailyChallenges: [
                    { id: 'hills', name: 'Build 3 hills', progress: 2, target: 3, reward: 100, completed: false },
                    { id: 'water', name: 'Create water flow', progress: 1, target: 1, reward: 50, completed: true }
                ],
                stats: {
                    terrainsModified: 1024,
                    vehiclesSpawned: 5,
                    sessionsPlayed: 47
                }
            };

            // Initialize particle system for effects
            if (typeof particlesJS !== 'undefined') {
                particlesJS('creative-overlay', {
                    particles: {
                        number: { value: 50 },
                        color: { value: '#00ff88' },
                        shape: { type: 'circle' },
                        opacity: { value: 0.3 },
                        size: { value: 3 },
                        move: { enable: true, speed: 1 }
                    }
                });
            }

            updateGameUI();
            startEnergyRegeneration();
        }

        function updateGameUI() {
            const state = window.gameState;

            // Update XP bar
            const xpFill = document.querySelector('.xp-fill');
            const xpText = document.querySelector('.xp-text');
            if (xpFill && xpText) {
                const percentage = (state.xp / state.xpToNext) * 100;
                xpFill.style.width = percentage + '%';
                xpText.textContent = `${state.xp.toLocaleString()} / ${state.xpToNext.toLocaleString()} XP`;
            }

            // Update energy meter
            const energyCount = document.getElementById('energy-count');
            if (energyCount) {
                energyCount.textContent = state.energy;
            }

            // Update metrics with streaks
            const terrainPoints = document.getElementById('terrain-points');
            if (terrainPoints) {
                terrainPoints.textContent = state.stats.terrainsModified.toLocaleString();
            }
        }

        function showAchievement(type) {
            const achievements = {
                speed: { title: '⚡ SPEED DEMON', desc: 'Maintained 60 FPS for 15 minutes!', xp: 150 },
                fleet: { title: '🚛 FLEET COMMANDER', desc: 'Managed 5+ vehicles simultaneously!', xp: 200 },
                terrain: { title: '🏔️ TERRAIN MASTER', desc: 'Modified 1000+ terrain points!', xp: 300 }
            };

            const achievement = achievements[type];
            if (achievement && !window.gameState.achievements.has(type)) {
                window.gameState.achievements.add(type);
                showAchievementPopup(achievement);
                addXP(achievement.xp);
            }
        }

        function showAchievementPopup(achievement) {
            const popup = document.createElement('div');
            popup.className = 'achievement-popup';
            popup.innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 24px; margin-bottom: 10px;">${achievement.title}</div>
                    <div style="font-size: 14px; margin-bottom: 10px;">${achievement.desc}</div>
                    <div style="font-size: 16px; color: #00FF88;">+${achievement.xp} XP</div>
                </div>
            `;
            document.body.appendChild(popup);

            // Trigger confetti effect
            if (typeof confetti !== 'undefined') {
                confetti({
                    particleCount: 100,
                    spread: 70,
                    origin: { y: 0.6 }
                });
            }

            setTimeout(() => popup.remove(), 3000);
        }

        function addXP(amount) {
            window.gameState.xp += amount;

            // Check for level up
            while (window.gameState.xp >= window.gameState.xpToNext) {
                window.gameState.xp -= window.gameState.xpToNext;
                window.gameState.level++;
                window.gameState.xpToNext = Math.floor(window.gameState.xpToNext * 1.2);

                showAchievementPopup({
                    title: `🎉 LEVEL ${window.gameState.level}!`,
                    desc: 'You leveled up! New abilities unlocked!',
                    xp: 0
                });
            }

            updateGameUI();
        }

        function activateBoost() {
            if (window.gameState.energy >= 20) {
                window.gameState.energy -= 20;

                // Apply boost effects
                showNotification('🚀 BOOST MODE ACTIVATED! +2x XP for 30 seconds', 'success');

                // Visual boost effect
                document.body.style.filter = 'hue-rotate(30deg) saturate(1.2)';
                setTimeout(() => {
                    document.body.style.filter = '';
                }, 30000);

                updateGameUI();
            } else {
                showNotification('⚡ Not enough energy! Need 20 energy to boost', 'warning');
            }
        }

        function resetWithReward() {
            if (window.gameState.energy >= 10) {
                window.gameState.energy -= 10;
                addXP(25);
                resetSandbox();
                showNotification('🔄 Terrain reset! +25 XP earned', 'success');
            } else {
                showNotification('⚡ Not enough energy! Need 10 energy to reset', 'warning');
            }
        }

        function togglePhysicsWithReward() {
            if (window.gameState.energy >= 5) {
                window.gameState.energy -= 5;
                addXP(5);
                togglePhysics();
                showNotification('⚛️ Physics toggled! +5 XP earned', 'success');
            } else {
                showNotification('⚡ Not enough energy! Need 5 energy for physics', 'warning');
            }
        }

        function saveWithReward() {
            addXP(10);
            saveSandbox();
            showNotification('💾 Progress saved! +10 XP earned', 'success');
        }

        function startEnergyRegeneration() {
            const energyRegenId = setInterval(() => {
                try {
                    if (window.gameState && window.gameState.energy < window.gameState.maxEnergy) {
                        window.gameState.energy = Math.min(window.gameState.maxEnergy, window.gameState.energy + 1);
                        if (typeof updateGameUI === 'function') {
                            updateGameUI();
                        }
                    }
                } catch (error) {
                    console.error('Energy regeneration error:', error);
                }
            }, 5000); // Regenerate 1 energy every 5 seconds

            // Store interval ID for cleanup
            if (!window.intervalIds) window.intervalIds = [];
            window.intervalIds.push(energyRegenId);

            return energyRegenId;
        }

        // ===== CRITICAL MEMORY LEAK FIXES - CLEANUP SYSTEM =====

        // Initialize cleanup arrays
        if (!window.intervalIds) window.intervalIds = [];
        if (!window.eventListeners) window.eventListeners = [];
        if (!window.websocketConnections) window.websocketConnections = [];

        // Enhanced event listener management with cleanup tracking
        function addEventListenerWithCleanup(element, event, handler, options = {}) {
            if (!element) {
                console.warn('Cannot add event listener to null element');
                return;
            }

            element.addEventListener(event, handler, options);
            window.eventListeners.push({ element, event, handler, options });
        }

        // Comprehensive cleanup function
        function cleanupResources() {
            console.log('🧹 Cleaning up resources...');

            // Clear all intervals (CRITICAL MEMORY LEAK FIX)
            if (window.intervalIds && window.intervalIds.length > 0) {
                window.intervalIds.forEach(id => {
                    clearInterval(id);
                    console.log(`Cleared interval: ${id}`);
                });
                window.intervalIds = [];
                console.log('✅ All intervals cleared');
            }

            // Remove all event listeners (MEMORY LEAK FIX)
            if (window.eventListeners && window.eventListeners.length > 0) {
                window.eventListeners.forEach(({ element, event, handler }) => {
                    try {
                        element.removeEventListener(event, handler);
                    } catch (error) {
                        console.warn('Failed to remove event listener:', error);
                    }
                });
                window.eventListeners = [];
                console.log('✅ All event listeners removed');
            }

            // Cleanup WebSocket connections
            if (window.websocketConnections && window.websocketConnections.length > 0) {
                window.websocketConnections.forEach(ws => {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.close();
                    }
                });
                window.websocketConnections = [];
                console.log('✅ All WebSocket connections closed');
            }

            // Cleanup canvas contexts and WebGL resources
            try {
                const canvases = document.querySelectorAll('canvas');
                canvases.forEach(canvas => {
                    const ctx = canvas.getContext('2d') || canvas.getContext('webgl') || canvas.getContext('webgl2');
                    if (ctx && ctx.getExtension) {
                        // Cleanup WebGL resources
                        const ext = ctx.getExtension('WEBGL_lose_context');
                        if (ext) ext.loseContext();
                    }
                });
                console.log('✅ Canvas contexts cleaned up');
            } catch (error) {
                console.warn('Canvas cleanup error:', error);
            }

            console.log('✅ Resource cleanup completed');
        }

        // Add cleanup on page unload (CRITICAL FOR MEMORY LEAKS)
        window.addEventListener('beforeunload', cleanupResources);
        window.addEventListener('unload', cleanupResources);

        // Add cleanup on visibility change (mobile/tablet support)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('Page hidden - reducing resource usage');
                // Optionally pause intervals when page is hidden for performance
            }
        });

        // Expose cleanup function globally for manual cleanup
        window.cleanupResources = cleanupResources;

        // Enhanced error boundary for critical functions
        function safeExecute(fn, context = 'Unknown') {
            try {
                return fn();
            } catch (error) {
                console.error(`Error in ${context}:`, error);
                if (window.logger) {
                    window.logger.error(`Safe execution failed in ${context}`, error);
                }
                return null;
            }
        }

        // Enhanced DOM element getter with null safety (PREVENTS NULL POINTER EXCEPTIONS)
        function safeGetElement(id, required = false) {
            const element = document.getElementById(id);
            if (!element && required) {
                console.error(`Required element not found: ${id}`);
                if (window.logger) {
                    window.logger.error(`Required DOM element missing: ${id}`);
                }
            }
            return element;
        }

        // Make safe functions globally available
        window.safeExecute = safeExecute;
        window.safeGetElement = safeGetElement;

        console.log('✅ Critical memory leak fixes and cleanup system initialized');
    </script>

    <!-- Kinect WebSocket Integration -->
    <script src="../js/kinect_websocket_integration.js"></script>
    <script>
        // Initialize Kinect WebSocket connection for RC Sandbox Clean
        let kinectIntegration;

        document.addEventListener('DOMContentLoaded', () => {
            kinectIntegration = new KinectWebSocketIntegration({
                onConnect: () => {
                    console.log('✅ RC Sandbox Clean connected to Kinect');
                    showNotification('🔗 Kinect depth server connected', 'success');
                },
                onDisconnect: () => {
                    console.log('❌ RC Sandbox Clean disconnected from Kinect');
                    showNotification('❌ Kinect depth server disconnected', 'warning');
                },
                onFrameData: (frameData) => {
                    if (window.terrain && window.terrain.updateFromKinectData) {
                        window.terrain.updateFromKinectData(frameData);
                    }
                },
                onTopographyData: (topographyData) => {
                    if (window.terrain && window.terrain.updateAIAnalysis) {
                        window.terrain.updateAIAnalysis(topographyData);
                    }
                }
            });

            kinectIntegration.connect();
        });
    </script>
</body>
</html>
